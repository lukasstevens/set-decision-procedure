\documentclass[sigplan,10pt,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[british]{babel}

\usepackage{mathpartir}

%\usepackage{unicode-math}
%\setmathfont{latinmodern-math.otf}
%\setmathfont[version=bold, FakeBold=2]{latinmodern-math.otf}

% Record brackets
\usepackage{stmaryrd}

\usepackage{xcolor}

\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}

\usepackage{enumitem}

\usepackage{array}
\usepackage{multirow}

\usepackage{listings}
\definecolor{isarblue}{HTML}{006699}
\definecolor{isargreen}{HTML}{009966}
\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,function,abbreviation,definition,proof,lemma,theorem,corollary,inductive},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and,fixes},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=\lst@ifdisplaystyle{fullflexible}\else{fixed}\fi,,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}
\makeatletter
\lst@AddToHook{OnEmptyLine}{\vspace{-0.4\baselineskip}}
\makeatother
\newcommand{\lstinlinew}[2][]{\lstinline[#1]{#2}}
% This is a hack to allow escaping inside lstinline (https://tex.stackexchange.com/questions/43526/escaping-in-lstinline)
\usepackage{etoolbox}
\makeatletter
\patchcmd{\lsthk@TextStyle}{\let\lst@DefEsc\@empty}{}{}{\errmessage{failed to patch}}
\makeatother

\usepackage{calc}

\newcommand{\textover}[3][l]{%
 % #1 is the alignment, default l
 % #2 is the text to be printed
 % #3 is the text for setting the width
 \makebox[\widthof{#3}][#1]{#2}%
}

\hyphenation{Isa-belle}
\hyphenation{tab-leau}

% % LuaLatex on Arxiv: https://tex.stackexchange.com/questions/372154/lualatex-how-to-produce-pdf-acceptable-by-arxiv 
% \hypersetup{%
%   pdfcreator = {},
%   pdfproducer = {}
% }
% \pdfvariable suppressoptionalinfo \numexpr 1+2+4+8+16+32+64+128+256+512 \relax

\usepackage{todonotes}

% Autoref names
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Section}

% Commands
\newcommand{\MLSS}{\textbf{MLSS}}

\newlength{\trianglewidth}
\settowidth{\trianglewidth}{\(\triangleleft\)}
\newcommand{\lefttrianglebar}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle; \draw (0, 0.75ex) -- (1ex, 0.75ex);}}}
\newcommand{\lefttriangle}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle;}}}

\newcommand{\lexpands}[2]{#1 $\lefttriangle$ #2}
\newcommand{\fexpands}[2]{#1 $\lefttrianglebar$ #2}
\newcommand{\fexpandsW}[2]{#1 $\lefttrianglebar_\text{v}$ #2}
\newcommand{\expandssSym}{\lefttriangle^*}
\newcommand{\expandss}[2]{#1 $\expandssSym$ #2}

\newcommand{\unionS}{\sqcup_\text{s}}
\newcommand{\interS}{\sqcap_\text{s}}
\newcommand{\diffS}{-_\text{s}}
\newcommand{\inS}{\in_\text{s}}
\newcommand{\notinS}{\notin_\text{s}}
\newcommand{\eqS}{=_\text{s}}
\newcommand{\neqS}{\neq_\text{s}}
\newcommand{\subseteqS}{\sqsubseteq_\text{s}}
\newcommand{\Ist}{I$_\text{st}$}
\newcommand{\Isa}{I$_\text{sa}$}

\newcommand{\fmAnd}[2]{#1 $\boldsymbol{\land}$ #2}
\newcommand{\fmOr}[2]{#1 $\boldsymbol{\lor}$ #2}
\newcommand{\fmNegSymbol}{\boldsymbol{\neg}}
\newcommand{\fmNeg}[1]{$\fmNegSymbol$ #1}
\newcommand{\fmAtom}{\textbf{A}}

\begin{document}

\setcounter{tocdepth}{1}

\title{Towards a Verified Tableau Prover for Multi-Level-Syllogistics}
\author{Lukas Stevens}
\orcid{0000-0003-0222-6858}
\affiliation{%
  \institution{Technical University of Munich}
  \department{Department of Informatics}
  \streetaddress{Boltzmannstr. 3}
  \city{Garching}
  \postcode{85748}
  \country{Germany}
}
\email{lukas.stevens@in.tum.de}

\begin{abstract}
  Using Isabelle/HOL, we verify the state-of-the-art decision procedure for multi-level syllogistics with singleton (\MLSS{} for short), which is a ground fragment of set theory.
  We formalise the syntax and semantics of \MLSS{} as well as a sound and complete tableau calculus for it.
  We also provide an abstract specification of a decision procedure that applies the rules of the calculus exhaustively and prove its termination.
\end{abstract}

\maketitle

\listoftodos{}

\section{Introduction}
\todo[inline]{\MLSS{} is multi-level syllogistics with singleton}

\subsection{Related work}
AFP entry~\cite{hybrid_logic_afp} and workshop paper in Isabelle 2022 workshop.

\subsection{Contributions}
Fill the proof of Lemma 2. More explicit proof of the cardinality of a branch.

\subsection{Notation}
Isabelle/HOL~\cite{isabelle} conforms to everyday mathematical notation for the most part.
For the benefit of the reader that is unfamiliar with Isabelle/HOL, we establish notation and in particular some essential datatypes together with their primitive operations that are specific to Isabelle/HOL.
We write \lstinline!t :: 'a! to specify that the term \lstinline!t! has the type \lstinline!'a! and \lstinline!'a $\Rightarrow$ 'b! for the type of a total function from \lstinline!'a! to \lstinline!'b!.
The types for booleans, natural numbers, and in integers are \lstinline!bool!, \lstinline!nat!, and \lstinline!int!, respectively.
Sets with elements of type \lstinline!'a! have the type \lstinline!'a set!.
Analogously, we use \lstinline!'a list! to describe lists, which are constructed as the empty list \lstinline![]! or with the infix constructor \lstinline!#!, and are appended with the infix operator \lstinline!@!.
The function \lstinline!set! converts a list into a set.
For optional values, Isabelle/HOL offers the type \lstinline!option! where a term \lstinline!opt :: 'a option! is either \lstinline!None! or \lstinline!Some a! with \lstinline!a :: 'a!.
Finally, we remark that \textbf{iff} is equivalent to \lstinline!$=$! on type \lstinline!bool! and \lstinline!$\equiv$! is definitional equality of the meta-logic of Isabelle/HOL, which is called Isabelle/Pure.
\todo[inline]{Add arrows and bracket notation for Pure formulae}
\section{Syntax and Semantics of MLSS\label{sec:semantics}}
\subsection{Syntax}
At the heart of \MLSS{}, we have the type of set terms which is the disjoint union of the empty set and variables as well as the operations union, intersection, set difference, and \lstinline!Single!, which represents a singleton set containing the argument.
\todo[inline]{Syntax for \lstinline!Single!?, overloading of \lstinline!vars_term!, \lstinline!vars_atom!}
\begin{lstlisting}
datatype (vars: 'a) pset_term =
  $\emptyset$ | Var 'a | Single ('a pset_term)
| 'a pset_term $\unionS$ 'a pset_term
| 'a pset_term $\interS$ 'a pset_term
| 'a pset_term $\diffS$ 'a pset_term
\end{lstlisting}
We can combine two set terms to form a set atom by using the membership or the equality operator.
\begin{lstlisting}
datatype (vars: 'a) pset_atom =
  'a pset_term $\inS$ 'a pset_term
| 'a pset_term $\eqS$ 'a pset_term
\end{lstlisting}
With the above operators we can also represent the subset operator \lstinline!$\subseteqS$! and enumerate finite sets as \lstinline!s $\subseteqS$ t! is equivalent to \lstinline!s $\unionS$ t $\eqS$ t! and a finite set of elements \lstinline!{t$_\text{1}$,$\ldots$,t$_\text{k}$}! can be expressed by \lstinline!Single t$_1$ $\unionS$ $\ldots$ $\unionS$ Single t$_k$!.

The unquantified fragment \MLSS{} of set theory is then formed by combining set atoms, which are injected into formulae with the constructor \lstinline!&\fmAtom&!, with propositional logical connectives.
\todo[inline]{Cite Nipkow's Linear Quantifier Elimination?, literals}
\begin{lstlisting}
datatype (atoms: 'a) fm =
  &\fmAtom& 'a | &\fmNeg{('a fm)}&
| &\fmAnd{'a fm}{'a fm}& | &\fmOr{'a fm}{'a fm}&

type_synonym 'a pset_fm = 'a pset_atom fm
\end{lstlisting}

\begin{lstlisting}
fun is_literal :: 'a fm $\Rightarrow$ bool where
  is_literal (&\fmAtom& _) = True
| is_literal (&\fmNeg{(\fmAtom{} \_)}&) = True
| is_literal _ = False
\end{lstlisting}
We will often drop the atom constructor \lstinline!&\fmAtom{}&! to reduce clutter.
Additionally, we use the abbreviations \lstinline!s $\notinS$ t! and \lstinline!s $\neqS$ t! to denote \lstinline!&\fmNeg{\fmAtom{} (s $\inS$ t)}&! and \lstinline!&\fmNeg{\fmAtom{} (s $\eqS$ t)}&!, respectively.
Note that Isabelle's datatype package automatically defines a function \lstinline!atoms :: 'a fm $\Rightarrow$ 'a set! that allows us to obtain all set atoms in a formula.
We combine these functions in order to define \lstinline!vars! that extracts all the variable names occuring in a set formula.
\todo[inline]{Motivation: one rule introduces new variables, Mention vars polymorphic}
\begin{lstlisting}
definition vars :: 'a pset_fm $\Rightarrow$ 'a set where
  vars $\phi$ $\equiv$ $\bigcup$(vars ` atoms $\phi$)
\end{lstlisting}

In addition to the variable names that appear in a formula, we will later also need to obtain those set terms that occur as subterms in a formula. 
We first define a function that collects the subterms of a set term.
\todo[inline]{Motivation: linear rules don't introduce subterms, \\ \lstinline!subterms b $\approx$ subterms (last b)!}
\begin{lstlisting}
fun subterms :: 'a pset_term
             $\Rightarrow$ 'a pset_term set where
  subterms $\emptyset$ = {$\emptyset$}
| subterms (Var x) = {Var x}
| subterms (s $\unionS$ t) =
    {s $\unionS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\interS$ t) =
    {s $\interS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\diffS$ t) =
    {s $\diffS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (Single t) =
    {Single t} $\cup$ subterms t
\end{lstlisting}
The subterms of an atom are then the subterms of those terms that make up the atom.
\begin{lstlisting}
fun subterms :: 'a pset_atom
             $\Rightarrow$ 'a pset_term set where
  subterms (s $\inS$ t) = subterms s $\cup$ subterms t
| subterms (s $\eqS$ t) = subterms s $\cup$ subterms t
\end{lstlisting}
Ultimately, we lift this to formulae by using \lstinline!atoms! again.
\begin{lstlisting}
definition subterms ::
    'a pset_fm $\Rightarrow$ 'a pset_term set where
  subterms $\phi$ $\equiv$ $\bigcup$(subterms ` atoms $\phi$)
\end{lstlisting}
The last function that we define computes the subformulae of a formula.
\begin{lstlisting}
fun subfms :: 'a fm $\Rightarrow$ 'a fm set where
  subfms (&\fmAtom& a) = {&\fmAtom& a}
| subfms (&\fmAnd{p}{q}&) =
    {&\fmAnd{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmOr{p}{q}&) =
    {&\fmOr{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmNeg{q}&) = {&\fmNeg{q}&} $\cup$ subfms q
\end{lstlisting}

\subsection{Semantics}
Formulae in \MLSS{} contain arbitrarily nested set terms.
We account for this arbitrary nesting by basing the semantics on the von Neumann hierarchy $\mathcal{V}$ of sets that is defined inductively as
\todo[inline]{Simplify definition by deleting cases?}
  \[
    \begin{array}{rclr}
      \mathcal{V}_0 & = & \emptyset, \\
      \mathcal{V}_{\alpha + 1} & = & \mathcal{P}(\mathcal{V}_\alpha) & \text{for each ordinal $\alpha$}, \\
      \mathcal{V}_{\lambda} & = & \bigcup_{\mu < \lambda} \mathcal{V}_\mu & \text{for each limit ordinal $\lambda$}, \\
      \mathcal{V} & = & \bigcup_\alpha \mathcal{V}_\alpha, \\
    \end{array}
  \]
where $\mathcal{P}(S)$ is the powerset of $S$.
The sets in $\mathcal{V}$ are well-founded meaning that there can be no membership cycle in $\mathcal{V}$.

In Isabelle/HOL, which is simply typed, this definition is not accepted, though.
A way to work around this limitiation is provided by Lawrence in an AFP entry~\cite{zfc_in_hol_afp}, which adds $\mathcal{V}$ to Isabelle/HOL by way of axiomatisation.
An article by Lawrence~\cite{zfc_in_hol} provides some further context to this entry.
The entry declares a type \lstinline!V! that comes with the following functionality:
\begin{itemize}
  \item The function \lstinline!elts :: V $\Rightarrow$ V set! maps a set to its elements.
      Note that even though we use the typed sets provided by Isabelle/HOL here, \lstinline!elts! actually returns a class.
      This class only constitutes a set if the class is small enough.
  \item The predicate \lstinline!small :: 'a set $\Rightarrow$ bool!, which is polymorphic in \lstinline!'a!, indicates whether a class is small.
  \item The function \lstinline!vset :: 'a set $\Rightarrow$ V! turns a class into a set of type \lstinline!V! if it is small. 
\item The usual set operations such as equality ($=$), union ($\sqcup$), intersection ($\sqcap$), and difference ($-$) are defined.
\item Finally, the empty set coincides with the ordinal $0$ so it is denoted by \lstinline!0 :: V!.
\end{itemize}

Equipped with the above, we define the interpretation function \lstinline!&\Ist&! for set terms that interprets a set term with respect to a valuation function \lstinline!M :: 'a $\Rightarrow$ V! for variable.
\begin{lstlisting}
fun &\Ist& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_term $\Rightarrow$ V where
  &\Ist& M $\emptyset$ = 0
| &\Ist& M (Var x) = M x
| &\Ist& M (Single s) = vset {&\Ist& M s}
| &\Ist& M (s $\unionS$ t) = &\Ist& M s $\sqcup$ &\Ist& M t 
| &\Ist& M (s $\interS$ t) = &\Ist& M s $\sqcap$ &\Ist& M t 
| &\Ist& M (s $\diffS$ t) = &\Ist& M s $-$ &\Ist& M t 
\end{lstlisting}
The interpretation function \lstinline!I$_\text{sa}$! for set atoms is straightforward as well.
\begin{lstlisting}
fun &\Isa& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_atom $\Rightarrow$ bool
where
  &\Isa& M (s $\inS$ t) $\longleftrightarrow$ &\Ist& M s $\in$ elts (&\Ist& M t)
| &\Isa& M (s $\eqS$ t) $\longleftrightarrow$ &\Ist& M s = &\Ist& M t
\end{lstlisting}
For formulae, we write \lstinline!M $\models$ $\phi$! for the judgement that $\phi$ holds under the valuation function \lstinline!M!.
We omit the implementation of $\models$ for brevity.
\todo[inline]{Add implementation? Add satisfiability!}

\section{A Tableau Calculus for MLSS}
We formalise the tableau calculus for \MLSS{} as described by \citeauthor{new_fast_tableau}~\cite{new_fast_tableau}.
Inspired by the formalisation of a tableau calculus for Hybrid Logic by \citeauthor{hybrid_logic_afp}~\cite{hybrid_logic_afp}, we simply use a list to represent a branch of the tableau tree.
Note that formulae are added to the front of the list during branch expansion so \lstinline!last b! for a branch \lstinline!b! is always the formula that we are trying to disprove with the tableau. 
\begin{lstlisting}
type_synonym 'a branch = 'a pset_fm list
\end{lstlisting}
We now lift the functions that extract the variables respectively subterms of formulae to branches.
\begin{lstlisting}
definition subterms ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms b $\equiv$ $\bigcup$(subterms ` set b)

definition vars :: 'a branch $\Rightarrow$ 'a set 
  vars b $\equiv$ $\bigcup$(vars ` set b)
\end{lstlisting}
In the standard tableau calculus for propositional logic, a branch is called \textit{closed} if it contains both the negation of a formula and the formula itself;
conversely, it is called \textit{open} if it is not closed.
For \MLSS{}, we extend the notion of closedness with three additional rules; the first two are straightforward while the last one states that a branch is closed when the branch contains a membership cycle
\begin{lstlisting}
  t$_\text{0}$ $\inS$ t$_\text{1}$, t$_\text{1}$ $\inS$ t$_\text{2}$, $\ldots$, t$_\text{k}$ $\inS$ t$_\text{0}$.
\end{lstlisting}

\begin{lstlisting}
inductive bclosed :: 'a branch $\Rightarrow$ bool where
  $\llbracket$ $\phi$ $\in$ set b; &\fmNeg{$\phi$}& $\in$ set b $\rrbracket$ $\Longrightarrow$ bclosed b
| (t $\inS$ $\emptyset$) $\in$ set b $\Longrightarrow$ bclosed b
| (t $\neqS$ t) $\in$ set b $\Longrightarrow$ bclosed b
| $\llbracket$ member_cycle cs; set cs $\subseteq$ set b$\rrbracket$
    $\Longrightarrow$ bclosed b

abbreviation bopen b $\equiv$ $\neg$ bclosed b
\end{lstlisting}
A tableau is called \textit{closed} if all of its branches are closed.

\subsection{Linear Expansion Rules}
\begin{table*}
  \lstset{
    escapeinside={@}{@}
  }
  \newcommand{\ton}{\text{t}_\text{1}}
  \newcommand{\ttw}{\text{t}_\text{2}}
  \begin{tabular}{p{0.21\textwidth}cp{0.18\textwidth} p{0.01\textwidth} p{0.21\textwidth}cp{0.18\textwidth}}
    \toprule
    \multicolumn{3}{c}{Propositional Rules} && \multicolumn{3}{c}{Rules for \lstinline!$\unionS$!} \\
    \cmidrule{1-3}\cmidrule{5-7}
    \lstinline!@\fmAnd{p}{q}@! & $\Longrightarrow$ & \lstinline!p, q! &&
    \lstinline!s $\notinS$ $\ton$ $\unionS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$, s $\notinS$ $\ttw$! \\

    \lstinline!@\fmNeg{(\fmOr{p}{q})}@! & $\Longrightarrow$ & \lstinline!@\fmNeg{p}@, @\fmNeg{q}@! &&
    \lstinline!s $\inS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$ $\unionS$ $\ttw$! \\

    \lstinline!@\fmOr{p}{q}, \fmNeg{p}@! & $\Longrightarrow$ & \lstinline!q! &&
    \lstinline!s $\in$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$ $\unionS$ $\ttw$! \\

    \lstinline!@\fmOr{p}{q}, \fmNeg{q}@! & $\Longrightarrow$ & \lstinline!p! &&
    \lstinline!s $\inS$ $\ton$ $\unionS$ $\ttw$, s $\notinS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ttw$! \\

    \lstinline!@\fmNeg{(\fmOr{p}{q})}@, p! & $\Longrightarrow$ & \lstinline!@\fmNeg{q}@! &&
    \lstinline!s $\inS$ $\ton$ $\unionS$ $\ttw$, s $\notinS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$! \\

    \lstinline!@\fmNeg{(\fmOr{p}{q})}@, q! & $\Longrightarrow$ & \lstinline!@\fmNeg{p}@! &&
    \lstinline!s $\notinS$ $\ton$, s $\notinS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$ $\unionS$ $\ttw$! \\
    \lstinline!@\fmNeg{(\fmNeg{p})}@! & $\Longrightarrow$ & \lstinline!p! &&&& \\[3ex]


    \multicolumn{3}{c}{Rules for \lstinline!$\interS$!} && \multicolumn{3}{c}{Rules for \lstinline!$\diffS$!} \\
    \cmidrule{1-3}\cmidrule{5-7}
    \lstinline!s $\inS$ $\ton$ $\interS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$, s $\inS$ $\ttw$! &&
    \lstinline!s $\inS$ $\ton$ $\diffS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$, s $\notinS$ $\ttw$! \\

    \lstinline!s $\notinS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$ $\interS$ $\ttw$! && 
    \lstinline!s $\notinS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$ $\diffS$ $\ttw$! \\

    \lstinline!s $\notinS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$ $\interS$ $\ttw$! &&
    \lstinline!s $\inS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$ $\diffS$ $\ttw$! \\

    \lstinline!s $\notinS$ $\ton$ $\interS$ $\ttw$, s $\inS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ttw$! && 
    \lstinline!s $\notinS$ $\ton$ $\diffS$ $\ttw$, s $\inS$ $\ton$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ttw$! \\

    \lstinline!s $\notinS$ $\ton$ $\interS$ $\ttw$, s $\inS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$! && 
    \lstinline!s $\notinS$ $\ton$ $\diffS$ $\ttw$, s $\notinS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\notinS$ $\ton$! \\

    \lstinline!s $\inS$ $\ton$, s $\inS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$ $\interS$ $\ttw$! &&
    \lstinline!s $\inS$ $\ton$, s $\notinS$ $\ttw$! & $\Longrightarrow$ & \lstinline!s $\inS$ $\ton$ $\diffS$ $\ttw$! \\[3ex]

    \multicolumn{3}{c}{Rules for \lstinline!Single!} && \multicolumn{3}{c}{Rules for \lstinline!$\eqS$!} \\
    \cmidrule{1-3}\cmidrule{5-7}
    & $\Longrightarrow$ & \lstinline!s $\inS$ Single s! &&
    \lstinline!$\ton$ $\eqS$ $\ttw$, l! & $\Longrightarrow$ & \lstinline!l{$\ttw$/$\ton$}! \\

    \lstinline!s $\inS$ Single t! & $\Longrightarrow$ & \lstinline!s $\eqS$ t! &&
    \lstinline!$\ton$ $\eqS$ $\ttw$, l! & $\Longrightarrow$ & \lstinline!l{$\ton$/$\ttw$}! \\

    \lstinline!s $\notinS$ Single t! & $\Longrightarrow$ & \lstinline!s $\neqS$ t! &&
    \lstinline!s$_\text{1}$ $\inS$ t, s$_\text{2}$ $\inS$ t! & $\Longrightarrow$ & \lstinline!s$_\text{1}$ $\neqS$ s$_\text{2}$! \\
    \bottomrule
  \end{tabular}
  \bigskip
  \caption{Linear expansion rules.\label{tab:lexpands}}
\end{table*}
The calculus considers two kinds of branch expansion rules: \textit{linear} and \textit{branching} rules.
As the name suggests, branching rules lead to the creation of new branches in the tableau while linear rules only extend a branch \lstinline!b! with new formulae \lstinline[breaklines=true]!b' = [$\psi_1$,$\ldots$,$\psi_n$]!, which we denote by \lstinline!&\lexpands{b'}{b}&!.
\autoref{tab:lexpands} shows all linear expansion rules.
Note that, in the first two rules for \lstinline!$\eqS$!, \lstinline!l! is a literal occuring in the branch.
Furthermore, the term-for-term substitution \lstinline!l{s/t}! is restricted to the top-level set terms of the literal;
for example, given the literal
\begin{lstlisting}
  l = &\fmNeg{((s $\unionS$ u) $\diffS$ s $\eqS$ s $\unionS$ u)}&
\end{lstlisting}
we have
\begin{lstlisting}
  &\phantom{=}& (&\fmNeg{((s $\unionS$ u) $\diffS$ s $\eqS$ s $\unionS$ u)}&){t/s $\unionS$ u}
  = &\fmNeg{((s $\unionS$ u) $\diffS$ s $\eqS$ t)}&.
\end{lstlisting}
The perhaps more crucial restriction of the linear rules is that that no new subterm may be created by their application;
for instance, the second rule for \lstinline!$\unionS$!
\begin{lstlisting}
  s $\inS$ t$_\text{1}$ $\Longrightarrow$ s $\inS$ t$_\text{1}$ $\unionS$ t$_\text{2}$,
\end{lstlisting}
which formally represents 
\begin{lstlisting}
  (s $\inS$ t$_\text{1}$) $\in$ set b $\Longrightarrow$ &\lexpands{[s $\inS$ t$_\text{1}$ $\unionS$ t$_\text{2}$]}{b}&,
\end{lstlisting}
may only be used under the condition
\begin{lstlisting}
  t$_\text{1}$ $\unionS$ t$_\text{2}$ $\in$ subterms (last b).
\end{lstlisting}
The purpose of this restriction is to prevent unbounded expansion of the branch.
In fact, we give an explicit upper bound for the number of formulae in a branch in \autoref{sec:bound}.

Due to boundedness, repeated application of linear rules eventually results in a \textit{linearly saturated} branch, i.e.\ a branch where no application of linear rules would produce new formulae.
\begin{lstlisting}
definition lin_sat b $\equiv$
  $\forall$b'. &\lexpands{b'}{b}& $\longrightarrow$ set b' $\subseteq$ set b
\end{lstlisting}

Finally, we remark that the original paper~\cite{new_fast_tableau} is missing the last propositional rules dealing with double negation.
This rule is required for completeness, though, considering that the branch
\begin{lstlisting}
  [&\fmNeg{\fmNeg{\fmNeg{p}}}&, p, &\fmAnd{\fmNeg{\fmNeg{\fmNeg{p}}}}{p}&]
\end{lstlisting}
is saturated --- neither linear nor branching rules apply --- and open but there is obviously no model for the initial formula \lstinline!&\fmAnd{\fmNeg{\fmNeg{\fmNeg{p}}}}{p}&!.

\subsection{Branching Rules\label{sec:branching}}
\begin{table*}
  \lstset{
    escapeinside={@}{@}
  }
  \newcommand{\ton}{\text{t}_\text{1}}
  \newcommand{\ttw}{\text{t}_\text{2}}
  \newcommand{\lpipe}{\rule[-0.4ex]{0.6pt}{2.3ex}}
  \begin{tabular}{>{\centering\arraybackslash}p{0.28\textwidth} >{\centering\arraybackslash}p{0.34\textwidth} >{\centering\arraybackslash}p{0.3\textwidth}}
    \toprule
    Rule & Precondition & Subsumption condition \\
    \midrule
    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!p! & \lpipe & \lstinline!@\fmNeg{p}@! \\
    \end{tabular}
         & \lstinline!@\fmOr{p}{q}@ $\in$ set b! & \lstinline!p $\in$ set b $\lor$ @\fmNeg{p}@ $\in$ set b! \\

    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!@\fmNeg{p}@! & \lpipe & \lstinline!p! \\
    \end{tabular}
         & \lstinline!@\fmNeg{(\fmAnd{p}{q})}@ $\in$ set b!
         & \lstinline!@\fmNeg{p}@ $\in$ set b $\lor$ p $\in$ set b! \\

    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!s $\inS$ $\ton$! & \lpipe & \lstinline!s $\notinS$ $\ton$! \\
    \end{tabular}
         &
         \begin{tabular}{c}
           \lstinline!(s $\inS$ $\ton$ $\unionS$ $\ttw$) $\in$ set  b! \\
           \lstinline!$\ton$ $\unionS$ $\ttw$ $\in$ subterms (last b)! \\
         \end{tabular}
         &
         \begin{tabular}{@{}rl@{}}
                  & \lstinline!(s $\inS$ $\ton$) $\in$ set b! \\
           $\lor$ & \lstinline!(s $\notinS$ $\ton$) $\in$ set b!
         \end{tabular}
         \\

    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!s $\inS$ $\ttw$! & \lpipe & \lstinline!s $\notinS$ $\ttw$! \\
    \end{tabular}
         &
         \begin{tabular}{c}
           \lstinline!(s $\inS$ $\ton$ $\interS$ $\ttw$) $\in$ set  b! \\
           \lstinline!($\ton$ $\interS$ $\ttw$) $\in$ subterms (last b)! \\
         \end{tabular}
         &
         \begin{tabular}{@{}rl@{}}
                  & \lstinline!(s $\inS$ $\ttw$) $\in$ set b! \\
           $\lor$ & \lstinline!(s $\notinS$ $\ttw$) $\in$ set b! \\
        \end{tabular}
        \\

    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!s $\inS$ $\ttw$! & \lpipe & \lstinline!s $\notinS$ $\ttw$! \\
    \end{tabular}
         &
         \begin{tabular}{c}
           \lstinline!(s $\inS$ $\ton$ $\diffS$ $\ttw$) $\in$ set  b! \\
           \lstinline!($\ton$ $\diffS$ $\ttw$) $\in$ subterms (last b)! \\
         \end{tabular}
         &
         \begin{tabular}{@{}rl@{}}
                  & \lstinline!(s $\inS$ $\ttw$) $\in$ set b! \\
           $\lor$ & \lstinline!(s $\notinS$ $\ttw$) $\in$ set b! \\
         \end{tabular} \\
         \addlinespace[0.6em]

    \begin{tabular}{@{}>{\raggedleft\arraybackslash}p{0.11\textwidth}c>{\raggedright\arraybackslash}p{0.11\textwidth}@{}}
      \\
      \midrule
      \lstinline!Var x $\inS$ $\ton$! \lstinline!Var x $\notinS$ $\ttw$! & \multirow{2}{*}{\rule[-0.4ex]{0.6pt}{4.8ex}} & \lstinline!Var x $\notinS$ $\ton$! \lstinline!Var x $\inS$ $\ttw$! \\
    \end{tabular}
         & 
         \begin{tabular}{c}
           \lstinline!($\ton$ $\neqS$ $\ttw$) $\in$ set b! \\
           \lstinline!$\ton$ $\in$ subterms (last b)! \\
           \lstinline!$\ttw$ $\in$ subterms (last b)! \\
           \lstinline!x $\notin$ vars b! \\
         \end{tabular}
         &
         \begin{tabular}{r@{\hspace{0.5em}}l}

           \lstinline!$\exists$s.! & \lstinline!(s $\inS$ $\ton$) $\in$ set b $\land$! \\
                                   & \lstinline!(s $\notinS$ $\ttw$) $\in$ set b! \\
           \multicolumn{2}{c}{$\lor$} \\
           \lstinline!$\exists$s.! & \lstinline!(s $\notinS$ $\ton$) $\in$ set b $\land$! \\
                                   & \lstinline!(s $\inS$ $\ttw$) $\in$ set b! \\
         \end{tabular}
         \\
         \bottomrule
  \end{tabular}
  \bigskip
  \caption{Branching expansion rules.\label{tab:bexpands}}
\end{table*}
After running out of linear rules apply, only the branching rules shown in \autoref{tab:bexpands} remain.
A rule is applicable if its \textit{precondition} is met and, to prevent unnecessary branching, it is not subsumed as indicated by the \textit{subsumption condition}.
These rules create multiple branches in the tableau so we represent the different possibilities \lstinline!bs'! to expand a branch \lstinline!b! as a set and write \lstinline!&\fexpands{bs'}{b}&!. 
Accordingly, we get a new branch \lstinline!b' @ b! in the tableau for each \lstinline!b' $\in$ set bs'!.

A linearly saturated branch where no further branching is possible is called a \textit{saturated} branch. 
\begin{lstlisting}
definition sat b $\equiv$ lin_sat b $\land$ ($\nexists$bs'. &\fexpands{bs'}{b}&)
\end{lstlisting}

Note that even branching rules are defined such that they never create new subterms with exception of the last rule, which adds a new variable to the branch.
These variables serve to manifest an inequality so we call them \textit{witnesses}.
\begin{lstlisting}
definition wits :: 'a branch $\Rightarrow$ 'a set where
  wits b $\equiv$ vars b - vars (last b)
\end{lstlisting}

\section{A Decision Procedure for MLSS}
\begin{figure*}
  \centering
\begin{lstlisting}
function (domintros) mlss_proc_branch :: 'a branch $\Rightarrow$ bool where
  $\neg$ lin_sat b
  $\Longrightarrow$ mlss_proc_branch = mlss_proc_branch ((SOME b'. &\lexpands{b'}{b}& $\land$ set b $\subset$ set (b' @ b)) @ b)
| $\llbracket$ lin_sat b; bclosed b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = True
| $\llbracket$ $\neg$ sat b; bopen b; lin_sat b $\rrbracket$
  $\Longrightarrow$ mlss_proc_branch b = ($\forall$b' $\in$ (SOME bs. &\fexpands{bs}{b}&). mlss_proc_branch (b' @ b))
| $\llbracket$ lin_sat b; sat b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = bclosed b

definition mlss_proc :: 'a pset_fm $\Rightarrow$ bool where
  mlss_proc $\phi$ $\equiv$ mlss_proc_branch [$\phi$]
\end{lstlisting}
\caption{Definition of the decision procedure through \lstinline|mlss_proc_branch| and \lstinline|mlss_proc|.\label{fig:alg}}
\end{figure*}

\noindent We abstractly specify the behaviour of the decision procedure, leaving an executable specification from which code can be generated to future work.
The implementation as displayed in \autoref{fig:alg} uses a couple features of Isabelle's function package:
instead of defining the function via pattern matching, we specify the equations of the function as conditional rewrite rules.
This requires us to prove that the assumptions of the equations are non-overlapping, which is done by automation.
The other concern is that Isabelle requires functions to be total so a recursive function needs to terminate in order for it to be well-defined;
nevertheless, the termination proof is separated from the definition of the function for modularity.
The function package maintains the soundness of the definition by introducing a so-called domain predicate \lstinline!mlss_proc_branch_dom! which characterises where the function terminates.
Each equation of the function receives the assumption that the predicate holds for the argument.
To be able to reason about this predicate, we pass the \lstinline!domintros! flag that instructs the function package to derive introduction rules for it.
Before we go into more detail on how the termination is handled, we discuss the definition of \lstinline!mlss_proc_branch!.

The purpose of the function is to take a branch and determine whether the branch can be expanded to a closed tableau.
As stated before, we first use linear expansion rules in order to prevent premature branching;
therefore, we recursively expand the branch with linear rules until the branch is linearly saturated.
Note that we use Hilbert's $\varepsilon$-operator in the form of \lstinline!SOME! to choose some rule that actually adds new formulae to the branch. 
As soon as the branch is linearly saturated, we terminate if the branch is closed as shown in the second equation.
Otherwise, we choose an applicable branching rule and recursively check whether all newly created branches can be closed.
The final equation applies once no further branch expansion is possible, in which case we just tests for closedness of the branch.

Every unsatisfiable formula has a closed tableau so we can determine the satisfiability of a formula \lstinline!$\psi$! by passing the singleton branch \lstinline![$\psi$]! to \lstinline!mlss_proc_branch!. 
Because this is the only context that \lstinline!mlss_proc_branch! is used in, it only encounters branches that result from applying branch expansion rules to a singleton branch.
We call this kind of branches \textit{well-formed}.
In the definition, the expression \lstinline!&\expandss{b'}{b}&! denotes that \lstinline!b'! is one of the branches that results from applying (potentially zero) expansion rules to \lstinline!b!.
\begin{lstlisting}
definition wf_branch b $\equiv$ $\exists$$\phi$. &\expandss{b}{[$\phi$]}&
\end{lstlisting}
In particular, we will use this notion in \autoref{sec:bound} where derive an upper bound for the cardinality of a well-formed branch.
This is then used in \autoref{sec:correct} to justify the termination of the decision procedure. 
Before we come to that, though, we prove soundness and completeness in Section~\ref{sec:sound} and~\ref{sec:complete}, respectively.
In \autoref{sec:correct}, we also show that both properties easily transfer to the decision procedure which, together with termination, gives us total correctness.

\section{Completeness of the Calculus\label{sec:complete}}
Once a branch \lstinline!b! is saturated and open at the same time, we are unable to expand the branch further in our calculus.
Thus, to establish completeness of the calculus, we must construct a model \lstinline!M! such that \lstinline!M $\models$ $\phi$! for all \lstinline!$\phi$ $\in$ set b!.

At the core of the model, there is a \textit{realisation} function that maps set terms to sets of type \lstinline!V!.
A subset of the witnesses, which we call \textit{pure} witnesses, receives special treatment from the realisation function for reasons that will become apparent in \autoref{sec:pwits}.
The set terms of a branch can thus be partitioned into two collections as defined below.
\begin{lstlisting}
definition wits' :: 'a branch $\Rightarrow$ 'a set where
  wits' b $\equiv$
    {c $\in$ wits b. $\forall$t $\in$ subterms (last b).
      AT (Var c $\eqS$ t) $\notin$ set b $\land$
      AT (t $\eqS$ Var c) $\notin$ set b} 

definition subterms' ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms' b $\equiv$
    subterms (last b) $\cup$ 
    Var ` (wits b - wits' b)
\end{lstlisting}

We aim to construct a syntactic model that is derived from the membership literals \lstinline!s $\inS$ t! in the branch.
To this end, we construct a graph whose vertices are the disjoint union of the sets above and there is an edge from \lstinline!s! to \lstinline!t! in the graph if, and only if, \lstinline!s $\inS$ t! is in \lstinline!b!.
Note that we use \citeauthor{graph_theory_afp}'s graph library~\cite{graph_theory_afp} where a graph is represented as a record of vertices, arcs (directed edges), and two functions \lstinline!tail! and \lstinline!head! that map an arc to its source respectively target vertex.
\begin{lstlisting}
definition bgraph b $\equiv$
  let vs = Var ` wits' b $\cup$ subterms' b
  in $\llparenthesis$ verts = vs,
     &$\phantom{\llparenthesis}$& arcs = {(s, t). (s $\inS$ t) $\in$ set b},
     &$\phantom{\llparenthesis}$& tail = fst, head = snd $\rrparenthesis$
\end{lstlisting}

The realisation function is defined relative to this graph.
As mentioned before, the pure witnesses \lstinline!Var ` wits' b! and the rest of the set terms \lstinline!subterms' b! are treated differently by the realisation function.
Terms in the latter set are evaluated in accordance to the structure of the graph, i.e.\ the realisation of a vertex is defined as the union of the realisations of the parent vertices. 
For the former set, we choose a function \lstinline!I! that assigns the witnesses in \lstinline!Var ` wits' b! pairwise distinct sets with cardinality greater than that of the vertices.
We can always choose such a function since we assume an infinite universe of variables.
Then, we return the singleton set \lstinline!vset {I x}!, which, together with the cardinality constraint, ensures that realisations are distinct between pure witnesses themselves as well as between pure witnesses and set terms.  
The notation \lstinline!u $\rightarrow_\text{G}$ s! in the definition below indicates that there is an edge from \lstinline!u! to \lstinline!s! in the graph \lstinline!G!.
\begin{lstlisting}
abbreviation parents G s $\equiv$ {u. u $\rightarrow_\text{G}$ s}

function realise :: 'a pset_term $\Rightarrow$ V where
  x $\in$ Var ` wits' b $\Longrightarrow$ realise x = vset {I x}
| x $\in$ subterms' b
  $\Longrightarrow$ realise t =
  &\phantom{$\Longrightarrow$ }&  vset {realise ` parents (bgraph b) s}
| x $\notin$ verts G $\Longrightarrow$ realise x = 0
\end{lstlisting}

Again, we need to ensure that the assumptions of the equations are non-overlapping and that function terminates.
The former is taken care of by automation, leaving us to prove termination.
The assumption that \lstinline!b! is open implies that there are no membership cycles and thus \lstinline!bgraph b! is acyclic.
Now, consider the ancestors \lstinline!av! of a vertex \lstinline!v!, which are those vertices from which we can reach \lstinline!v!.
Due to acyclicity, it holds that the ancestors \lstinline!ap! of a parent \lstinline!p! of \lstinline!v! are a subset of \lstinline!av!.
They are also a proper subset of \lstinline!av! since \lstinline!p! is an ancestor of \lstinline!v! but not of \lstinline!p! itself.
Together with the fact that \lstinline!bgraph b! is finite, it follows that the cardinality of the ancestors decreases in each recursive call thus proving the termination of \lstinline!realise!.

Before we prove that the realisation function constitutes a model in \autoref{sec:real}, we will first explain the significance of the pure witnesses.

\subsection{Characterisation of the Pure Witnesses\label{sec:pwits}}
Recall that the pure witnesses for a branch \lstinline!b! are those witnesses that are not related to other subterms in \lstinline!last b! by equality.
In the context of a well-formed branch, this characterisation can be strengthened to any set term and, in addition, we also get that there is no membership literal where a pure witness is on the right-hand side.
Intuitively speaking, the realisation of a pure witness does not depend on the realisation of any other set term.
\begin{lstlisting}[label={lst:lemma_2}]
lemma lemma_2:
  assumes wf_branch b
  assumes c $\in$ wits' b
  shows (Var c $\eqS$ t) $\notin$ set b
    and (t $\eqS$ Var c) $\notin$ set b
    and (t $\inS$ Var c) $\notin$ set b
\end{lstlisting}
So why are pure witnesses treated differently?
According to the definition of \lstinline!realise!, the pure witnesses would be evaluated to the empty set \lstinline!0 :: V!, were they not treated separately. 
To see that this is a problem, consider the branch
\begin{lstlisting}
  b = [Var s $\neqS$ Var t, Var t $\neqS$ Var u]
\end{lstlisting}
which expands to several open and saturated branches, one of which is
\begin{lstlisting}
  [Var x $\neqS$ Var y,
   Var x $\inS$ Var s, Var x $\notinS$ Var t,
   Var y $\inS$ Var t, Var y $\notinS$ Var u] @ b
\end{lstlisting}
for some fresh \lstinline!x! and \lstinline!y!.
Assigning both \lstinline!Var x! and \lstinline!Var y! a value of \lstinline!0! would contradict the literal \lstinline!Var x $\neqS$ Var y!.
To prevent this, we assign the pure witnesses pairwise different values.

The proof of \hyperref[lst:lemma_2]{\lstinline!lemma_2!} is more technical than interesting so we refer the reader to the formalisation.

\subsection{Realisation of an Open Branch\label{sec:real}}
Remember that for completeness, we need to show that the realisation function for an open and saturated branch \lstinline!b! actually constitutes a model for all formulae in the branch.
We start by verifying that the realisation function models all literals in the branch; more formally, the following propositions hold: 
\begin{enumerate}[label=(\roman*)]
  \item\label{it:at_mem} We have \lstinline!realise s $\in$ elts (realise t)! if it holds that \lstinline!s $\inS$ t! is in \lstinline!b!. 
  \item\label{it:at_eq} We have \lstinline!realise s $=$ realise t! if \lstinline!s $\eqS$ t! is in \lstinline!b!.
  \item\label{it:af_eq} We have \lstinline!realise s $\neq$ realise t! if \lstinline!s $\neqS$ t! is in \lstinline!b!.
  \item\label{it:af_mem} We have \lstinline!realise s $\notin$ elts (realise t)! if it holds that \lstinline!s $\notinS$ t! is in \lstinline!b!. 
\end{enumerate}
To illustrate the usefulness of \hyperref[lst:lemma_2]{\lstinline!lemma_2!}, we prove Proposition~\ref{it:at_eq}.
The proofs of all propositions translate well into Isabelle so we refer to the original paper~\cite{new_fast_tableau} for the remaining proofs. 
\begin{proof}[Proof of Proposition~\ref{it:at_eq}]
  Assume that \lstinline!s $\eqS$ t! is in \lstinline!b!.
  If there exists a \lstinline!c $\in$ wits' b! where \lstinline!s = Var c! or \lstinline!t = Var c!, we arrive at a contradiction due to \hyperref[lst:lemma_2]{\lstinline!lemma_2!}.
  Therefore, both \lstinline!s $\in$ subterms' b! and \lstinline!t $\inS$ subterms' b! must hold.
  Now, assume for contradiction that
\begin{lstlisting}
  &\phantom{$\Longrightarrow$}& realise s $\neq$ realise t
  $\Longrightarrow$ elts (realise s) $\neq$ elts (realise t).
\end{lstlisting}
  Without loss of generality --- the other case is symmetric ---, we obtain an \lstinline!a! such that
\begin{lstlisting}
  a $\in$ elts (realise s) $\land$ a $\notin$ elts (realise t). 
\end{lstlisting}
  Considering the fact that \lstinline!s $\in$ subterms' b! and the definition of \lstinline!realise!, we obtain an \lstinline!u! such that \lstinline!a = realise u! and \lstinline!u $\rightarrow_\text{bgraph b}$ s!.
  This, in turn, yields that \lstinline!u $\inS$ s! must be in \lstinline!b!.
  Together with the assumption \lstinline!(s $\eqS$ t) $\in$ b! and the openness of \lstinline!b!, it follows that \lstinline!u $\inS$ t! must also be in \lstinline!b!.
  But then we have
\begin{lstlisting}[columns=fixed]
  realise u $\in$ elts (realise t)
        = a $\in$ elts (realise t)
\end{lstlisting}
  using Proposition~\ref{it:at_mem}, which stands in contradiction to the assumption \lstinline!a $\notin$ elts (realise t)!.
\end{proof}

\noindent The results on literals can now be lowered to set terms.
\begin{enumerate}[label=(\alph*)]
  \item\label{it:empty} It holds that \lstinline!realise $\emptyset$ = 0!.
  \item\label{it:op} Let \lstinline!$\star_\text{s}$ $\in$ {$\unionS$, $\diffS$, $\interS$}!. If the term \lstinline!s $\star_\text{s}$ t! occurs in \lstinline!subterms b!, then
    \begin{center}
    \lstinline!realise (s $\star_\text{s}$ t) = realise s $\star$ realise t!.
    \end{center}
  \item\label{it:single} If \lstinline!Single t $\in$ subterms b!, then
    \begin{center}
    \lstinline!realise (Single t) = vset {realise t}!.
    \end{center}
\end{enumerate}
\begin{proof}[Proof of Proposition~\ref{it:empty}]
  By definition, \lstinline!realise $\emptyset$! is equal to \lstinline!0! if \lstinline!$\emptyset$! is not a vertex of \lstinline!bgraph b!.
  Otherwise, \lstinline!$\emptyset$! must be in \lstinline!subterms' b! as it is not a witness.
  Moreover, since \lstinline!b! is open, we know \lstinline!s $\inS$ $\emptyset$! is not in \lstinline!b! for any \lstinline!s!, implying that the term \lstinline!$\emptyset$! has no parents in \lstinline!bgraph b!.
  Ultimately, we obtain \lstinline!realise $\emptyset$ = 0!.
\end{proof}
\begin{proof}[Proof of Proposition~\ref{it:op} for $\star_\texttt{s} = -_\texttt{s}$]
  For equality, it suffices to prove subset inclusion in both directions.

  \textbf{Direction $\subseteq$. } Fix some \lstinline!e! in \lstinline!elts (realise (s $\diffS$ t))!.
  Again, we obtain an \lstinline!u! with 
\begin{lstlisting}
  e = realise u $\land$ u $\rightarrow_\text{bgraph b}$ (s $\diffS$ t).
\end{lstlisting}
  We therefore have \lstinline!(u $\inS$ s $\diffS$ t) $\in$ set b! which, due to \lstinline!b! being saturated, implies that \lstinline!u $\inS$ s! and \lstinline!u $\notinS$ t! are in \lstinline!b!.
  \todo[inline]{Explain latter of line above}
  By applying Proposition~\ref{it:at_mem} and~\ref{it:af_mem} we obtain
\begin{lstlisting}
  realise u $\in$ realise s $\land$ realise u $\notin$ realise t
\end{lstlisting}
  and together with \lstinline!e = realise u! we arrive at the goal 
\begin{lstlisting}
  e $\in$ elts (realise s - realise t).
\end{lstlisting}

\textbf{Direction $\supseteq$. } Let \lstinline[columns=fullflexible]!e $\in$ elts (realise s - realise t)! for some fixed \lstinline!e!.
  As before, we obtain an \lstinline!u! such that \lstinline!e! is the realisation of \lstinline!u!, i.e.\ \lstinline!e = realisation u!, and
\begin{lstlisting}
  u $\rightarrow_\text{bgraph b}$ s $\land$ u $\nrightarrow_\text{bgraph b}$ t.
\end{lstlisting}
  An immediate consequence is that \lstinline!u $\inS$ s! is in \lstinline!b!.
  Moreover, we claim that \lstinline!u $\notinS$ t! is also in \lstinline!b!.
  To see that this is true, recall that \lstinline!b! is saturated and thus the subsumption condition of rule TODO needs to hold.
  This implies that either \lstinline!u $\inS$ t! or \lstinline!u $\notinS$ t! is in \lstinline!b! but the latter being in \lstinline!b! would be a contradiction to \lstinline!u $\nrightarrow_\text{bgraph b}$ t! meaning that the former must hold.
  Ultimately, we infer that \lstinline!u $\in$ s $\diffS$ t! is in \lstinline!b! by invoking saturation again.
  The last step is to apply Proposition~\ref{it:at_mem} in order to obtain the goal
  \begin{lstlisting}
    realise u $\in$ elts (realise (s $\diffS$ t))
    &\textover[r]{=}{realise}& e $\in$ elts (realise (s $\diffS$ t)).
  \end{lstlisting}
\end{proof}

\noindent The final step towards obtaining a proper model is to connect the realisation function to the semantics as defined in \autoref{sec:semantics}.
For set terms, we can use the Propositions~\ref{it:empty}--\ref{it:single} to prove the lemma below by induction on \lstinline!t!.
\begin{lstlisting}
lemma
  assumes t $\in$ subterms b
  shows &\Ist& ($\lambda$x. realise (Var x)) t = realise t
\end{lstlisting}
Lifting the above result to formulae yields the coherence of \lstinline!b! as the original paper~\cite{new_fast_tableau} calls it.
The proof is a tedious but straightforward induction on the the size of the formulae.
\begin{lstlisting}[label={lst:coherence}]
lemma coherence:
  assumes $\phi$ $\in$ set b
  shows ($\lambda$x. realise (Var x)) $\models$ $\phi$
\end{lstlisting}
The coherence property finishes the proof of completeness of the calculus as it gives us a model for every formula in an open and saturated branch.

\section{Soundness of the Calculus\label{sec:sound}}
Two aspects determine the soundness of the calculus: a closed branch must be unsatisfiable and all expansion rules must maintain satisfiability.
We can express the former aspect in Isabelle as follows.
\begin{lstlisting}[belowskip=0pt,label={lst:bclosed_sound}]
lemma bclosed_sound:
  assumes bclosed b shows $\exists$$\phi$ $\in$ set b. M $\not\models$ $\phi$
\end{lstlisting}
\begin{proof}
  Assume for contradiction that \lstinline!b! is closed but we have a model, i.e.\ it holds that \lstinline!$\forall$$\phi$ $\in$ set b. M $\models$ $\phi$!.
  We perform a case analysis on \lstinline!bclosed b!.
  It is clear that, for any \lstinline!s!, neither does \lstinline!M! model \lstinline!s $\in$ $\emptyset$! nor \lstinline!s $\neqS$ s!.
  Furthermore, no model can satisfy both \lstinline!$\phi$! and \lstinline!&\fmNeg{$\phi$}&! at the same time.
  This leaves us with the case where \lstinline!b! contains a membership cycle
\begin{lstlisting}
  t$_\text{0}$ $\inS$ t$_\text{1}$, t$_\text{1}$ $\inS$ t$_\text{2}$, $\ldots$, t$_\text{k}$ $\inS$ t$_\text{0}$.
\end{lstlisting}
  By assumption, each atom of the membership cycle holds under the model \lstinline!M!; in other words, we have
\begin{lstlisting}
  &\Ist& M t$_\text{i}$ $\in$ elts (&\Ist& M t$_\text{i + 1 mod k + 1}$)
\end{lstlisting}
  for each \lstinline!i $\in$ {0,$\ldots$,k}!.
  Therefore, the transitive closure of the membership relation \lstinline!{(x, y). x $\in$ elts y}! contains a cycle. 
  This, however, is a contradiction since the membership relation of \lstinline!V! is well-founded (see \autoref{sec:semantics}) and well-foundedness is closed under transitive closure.
\end{proof}

\noindent We are left with showing that both linear and branching expansion rules preserve satisfiability.
As for the linear rules, a straightforward proof by case analysis on \lstinline!&\lexpands{b'}{b}&! suffices to obtain the lemma below.
\begin{lstlisting}[label={lst:lexpands_sound}]
lemma lexpands_sound:
  assumes &\lexpands{b'}{b}& and $\phi$ $\in$ set b'
  assumes $\bigwedge$$\psi$. $\psi$ $\in$ set b $\Longrightarrow$ M $\models$ $\psi$
  shows M $\models$ $\phi$
\end{lstlisting}
A similar argument would work for the branching rules if it were not for the last rule adding new variables.
Those variables need to be assigned specific values; hence, we modify the model as we will see in the proof below.
\begin{lstlisting}[belowskip=0pt, label={lst:bexpands_sound}]
lemma bexpands_sound:
  assumes &\fexpands{bs'}{b}&
  assumes $\bigwedge$$\psi$. $\psi$ $\in$ set b $\Longrightarrow$ M $\models$ $\psi$
  shows $\exists$M'. $\exists$b' $\in$ bs'.
          $\forall$$\psi$ $\in$ set (b' @ b). M' $\models$ $\psi$
\end{lstlisting}
\begin{proof}
  We perform a case analysis on the derivation \lstinline!&\fexpands{bs'}{b}&!.
  As all cases but that of the last rule are straightforward, we only consider this last case where we have 
\begin{lstlisting}
  bs' = {[Var x $\inS$ s, Var x $\notinS$ t],
         [Var x $\inS$ t, Var x $\notinS$ s]}
\end{lstlisting}
  for some fresh variable \lstinline!x!, i.e.\ \lstinline!x $\notin$ vars b! and in particular \lstinline!x $\notin$ vars s $\cup$ vars t!.
  Another consequence of the last rule being applied is that \lstinline!s $\neqS$ t! is in \lstinline!b!, which, because \lstinline!M! is a model, implies that \lstinline!&\Ist& M s $\neq$ &\Ist& M t!.
  This inequality manifests itself through some \lstinline!y! with
\begin{lstlisting}
  &\phantom{$\lor$}& y $\in$ elts (&\Ist& M s) $\land$ y $\notin$ elts (&\Ist& M t)
  $\lor$ y $\in$ elts (&\Ist& M t) $\land$ y $\notin$ elts (&\Ist& M s).
\end{lstlisting}
  We now update the assignment \lstinline!M! such that it maps \lstinline!x! to \lstinline!y! to obtain the assignment \lstinline!M'!.
  Note that values of both \lstinline!s! and \lstinline!t! are unchanged under this update as \lstinline!x $\notin$ vars s! and \lstinline!x $\notin$ vars t!.
  Considering our assumption about \lstinline!y! and the fact that \lstinline!&\Ist& M' (Var x) = y!, we infer that
\begin{lstlisting}
  $\exists$b' $\in$ bs'. $\forall$$\psi$ $\in$ set b'. M' $\models$ $\psi$.
\end{lstlisting}
  In other words, due to the disjunction, it holds that \lstinline!M'! is a model for one \lstinline!b' $\in$ bs!.
  Thus, we are left with proving that \lstinline!M'! is a model for \lstinline!b!.
  This is indeed the case since the assumption \lstinline!M $\models$ $\psi$! is equivalent to \lstinline!M' $\models$ $\psi$! for all \lstinline!$\psi$ $\in$ set b! given that \lstinline!x! is fresh with respect to b.
\end{proof}

\section{Upper Bounding the Cardinality of a Branch\label{sec:bound}}
Soundness and completeness of the calculus are the building blocks with which we establish partial correctness of the algorithm in \autoref{fig:alg}.
Consequently, we still need to give a termination proof to ascertain total correctness.
The core of our argument is that the number of distinct formulae that can be derived with the expansion rules is finite.
In particular, we claim that the following upper bound holds.
\begin{lstlisting}
  &\phantom{$\leq$}& card (set b)
  &\textover{$=$}{$\leq$}& card {$\psi$ $\in$ set b. $\neg$ is_literal $\psi$} +
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. is_literal $\psi$}
  $\leq$ 2 * card (subfms (last b)) +
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. is_literal $\psi$}
  $\leq$ 2 * card (subfms (last b)) +
  &\phantom{$\leq$}& 16 * (card (subterms (last b)))$^4$
\end{lstlisting}
We treat both inequalities separately, starting with the first one whose justification hinges on an invariant: 
every new composite subformula that is introduced by an expansion rule is the negation of a subformula that already occurs in \lstinline!last b!.
Written as a formula, we have
\begin{lstlisting}
  &\phantom{$\subseteq$}& {$\psi$ $\in$ set b. $\neg$ is_literal $\psi$}
  $\subseteq$ subfms (last b) $\cup$ $\fmNegSymbol$ ` subfms (last b).
\end{lstlisting}
Confirming that this is an invariant is an easy exercise of going through each of the propositional rules in \autoref{tab:lexpands} and the first two branching rules in \autoref{tab:bexpands}.
Thus, we have
\begin{lstlisting}
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. $\neg$ is_literal $\psi$}
  $\leq$ card (subfms (last b)) +
  &\phantom{$\leq$}& card ($\fmNegSymbol$ ` subfms (last b))
  $\leq$ 2 * card (subfms (last b))
\end{lstlisting}
which is the first inequality we asserted. 

Concerning the second inequality, first observe that each literal contains an atom, implying that the set of literals is at most twice as large as the set of atoms in a branch. 
In addition, an atom is formed by combining two subterms occuring in the branch with either \lstinline!$\inS$! or \lstinline!$\eqS$!, ultimately yielding
\begin{lstlisting}
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. is_literal $\psi$}
  $\leq$ 2 * card ($\bigcup$(atoms ` set b))
  $\leq$ 2 * 2 * (card (subterms b))$^\text{2}$.
\end{lstlisting}
Since no expansion rule introduces new subterms, we know the cardinality of the subterms in a branch \lstinline!b! is limited by the subterms of \lstinline!last b! plus the number of witnesses added to the branch.
Regarding an upper bound for the witnesses, recognise that the last branching rule requires \lstinline!s $\neqS$ t! to be in \lstinline!b! for some \lstinline!s,t $\in$ subterms (last b)!.
The subsumption condition then prohibits that the rule can be applied again for the combination of \lstinline!s! and \lstinline!t!, thus yielding an upper bound of \lstinline!(card (subterms (last b)))$^\text{2}$!.
This allows us to finish the calculation that justifies the second inequality:
\begin{lstlisting}
  &\phantom{$\leq$}& 4 * (card (subterms b))$^\text{2}$
  $\leq$ 4 * (card (subterms (last b))
  &\phantom{$\leq$}&      + card (wits b))$^\text{2}$
  $\leq$ 4 * (card (subterms (last b))
  &\phantom{$\leq$}&      + (card (subterms (last b))$^\text{2}$)$^\text{2}$
  $\leq$ 4 * 4 * (card (subterms (last b)))$^\text{4}$.
\end{lstlisting}
All in all, we get the following lemma.
\begin{lstlisting}[label={lst:card_branch}]
lemma card_wf_branch_ub:
  assumes wf_branch b
  shows card (set b)
        $\leq$ 2 * card (subfms (last b)) +
        &\phantom{$\leq$}& 16 * (card (subterms (last b)))$^\text{4}$
\end{lstlisting}

\section{Total Correctness of the Decision Procedure\label{sec:correct}}
We first prove the termination of the procedure for well-formed branches, i.e.\ every well-formed branch is in the domain of \lstinline!mlss_proc_branch!.
\begin{lstlisting}[belowskip=0pt]
lemma mlss_proc_branch_dom_if_wf_branch:
  assumes wf_branch b
  shows mlss_proc_branch_dom b
\end{lstlisting}
\begin{proof}
  We proceed by strong induction on the difference between the upper bound due to \hyperref[lst:card_branch]{\lstinline!card_wf_branch_ub!} and \lstinline!card b!.

  We only have one inductive case where the induction hypothesis holds for all well-formed branches \lstinline!b'! where the difference between the upper bound and the cardinality is smaller than that of \lstinline!b!.
  We strengthen those assumptions to obtain
\begin{lstlisting}
  $\llbracket$ expandss b' b; set b $\subset$ set b' $\rrbracket$
  $\Longrightarrow$ mlss_proc_branch_dom b'
\end{lstlisting}
for all \lstinline!b'!.
The former strengthening is admissable since, by definition, every expansion of a well-formed branch is again well-formed while the latter ensures that the cardinality of \lstinline!b'! is larger than the cardinality of \lstinline!b!, ensuring that the difference to the upper bound decreases.

Now, consider the case where \lstinline!b! is saturated.
Then, the procedure terminates without recursive calls and we immediately get \lstinline!mlss_proc_branch_dom b! using the corresponding introduction rule for the domain predicate.

If \lstinline!b! is not saturated, we can expand \lstinline!b! using a linear or a branching rule, which adds new formulae to the resulting branch(es).
In the first case, we can thus, using \lstinline!SOME!, choose a branch \lstinline!b'! that linearly expands \lstinline!b!.
Moreover, the domain predicate holds for \lstinline!b' @ b! since the assumptions of the modified induction hypothesis are fulfilled.
Ultimately, we use the corresponding introduction rule for the domain predicate to obtain \lstinline!mlss_proc_branch b!.

The case of a branching rule is analogous.
\end{proof}

\noindent The above lemma allows us to use the computation induction rule of \lstinline!mlss_proc_branch! on well-formed branches, which we do to prove soundness and completeness, starting with completeness.
\begin{lstlisting}[belowskip=0pt]
lemma mlss_proc_branch_complete:
  fixes b :: 'a branch
  assumes wf_branch b
  assumes $\neg$ mlss_proc_branch b
  assumes infinite (UNIV :: 'a set)
  shows $\exists$M. M $\models$ last b
\end{lstlisting}
\begin{proof}
  We prove the completeness by computation induction on \lstinline!b!.

  The case of the first and third equation, where the branch can be expanded, are immediately resolved with the induction hypothesis.

  We evaluate \lstinline!mlss_proc_branch b! to \lstinline!True! in the case of the third equation, yielding a contradiction with the assumption \lstinline!$\neg$ mlss_proc_branch b!.

  This leaves us with the final case where we assume that the branch is saturated and \lstinline!mlss_proc_branch b! evaluates to \lstinline!bclosed b!.
  The branch, however, must be open due to the assumption \lstinline!$\neg$ mlss_proc_branch b!.
  This allows us to use the Lemma~\hyperref[lst:coherence]{\lstinline!coherence!} to obtain the model
\begin{lstlisting}
  ($\lambda$x. realise (Var x)) $\models$ last b.
\end{lstlisting}
\end{proof}

\noindent With completeness out of the way, only soundness remains to be proven. 
\begin{lstlisting}[belowskip=0pt]
lemma mlss_proc_branch_sound:
  assumes wf_branch b
  assumes $\forall$$\psi$ $\in$ set b. M $\models$ $\psi$
  shows $\neg$ mlss_proc_branch b
\end{lstlisting}
\begin{proof}
  We proceed by assuming \lstinline!mlss_proc_branch b! and deriving \lstinline!False!.
  Using the assumptions, we can prove that there exists \lstinline!b'! such that
\begin{lstlisting}
  expandss b' b $\land$
  ($\exists$M. $\forall$$\psi$ $\in$ set b'. M $\models$ $\psi$) $\land$ bclosed b'
\end{lstlisting}
  by computation induction on \lstinline!b!.

  In the case where we choose a branching rule to expand \lstinline!b! with the branches in \lstinline!bs'!, we use Lemma~\hyperref[lst:lexpands_sound]{\lstinline!bexpands_sound!} to obtain \lstinline!b' $\in$ bs'! and \lstinline!M'! with
\begin{lstlisting}
  $\forall$$\psi$ $\in$ set (b' @ b). M' $\models$ $\psi$.
\end{lstlisting}
  Together with the induction hypothesis, we obtain a \lstinline!b''! where 
\begin{lstlisting}
  expandss b'' (b' @ b) $\land$
  ($\exists$M. $\forall$$\psi$ $\in$ set b''. M $\models$ $\psi$) $\land$ bclosed b''.
\end{lstlisting}
  Due to the transitivity of \lstinline!expandss!, the above also holds if we replace \lstinline!b' @ b! with \lstinline!b!, which is our goal.

  The case of a linear expansion is dealt with in an analogous manner using Lemma~\hyperref[lst:lexpands_sound]{\lstinline!lexpands_sound!}.

  The two remaining cases are trivial as the branch is already closed, finishing the proof of the proposition.

  This proposition, however, is a contradiction to the statement of Lemma~\hyperref[lst:bclosed_sound]{\lstinline!bclosed_sound!}: no closed branch can have a model. 
\end{proof}

\noindent To finish of the proof of total correctness, note that every singleton branch is trivially well-formed so termination, completeness, and soundness easily transfer to \lstinline!mlss_proc!.
\begin{lstlisting}
theorem mlss_proc_complete:
  fixes $\phi$ :: 'a pset_fm
  assumes $\neg$ mlss_proc $\phi$
  assumes infinite (UNIV :: 'a set)
  shows $\exists$M. M $\models$ $\phi$

theorem mlss_proc_sound:
  assumes M $\models$ $\phi$
  shows $\neg$ mlss_proc $\phi$
\end{lstlisting}

\section{Future Work}
Challenges in obtaining an executable specification: membership cycle test unnecessary, fast branch membership test, proof reconstruction.
Additional constructs such as finiteness and pairs.
Optimisations for the algorithm.

\section{Conclusion}

\begin{acks}
  \todo[inline]{Acknowledge}
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sources}

\end{document}
