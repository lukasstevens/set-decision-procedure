\documentclass[sigplan,10pt,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[british]{babel}

\usepackage{mathpartir}

%\usepackage{unicode-math}
%\setmathfont{latinmodern-math.otf}
%\setmathfont[version=bold, FakeBold=2]{latinmodern-math.otf}

% Record brackets
\usepackage{stmaryrd}

\usepackage{xcolor}

\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}

\usepackage{enumitem}

\usepackage{listings}
\definecolor{isarblue}{HTML}{006699}
\definecolor{isargreen}{HTML}{009966}
\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,function,abbreviation,definition,proof,lemma,theorem,corollary,inductive},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=\lst@ifdisplaystyle{fullflexible}\else{fixed}\fi,,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}
\makeatletter
\lst@AddToHook{OnEmptyLine}{\vspace{-0.4\baselineskip}}
\makeatother
% This is a hack to allow escaping inside lstinline (https://tex.stackexchange.com/questions/43526/escaping-in-lstinline)
\usepackage{etoolbox}
\makeatletter
\patchcmd{\lsthk@TextStyle}{\let\lst@DefEsc\@empty}{}{}{\errmessage{failed to patch}}
\makeatother

\usepackage{calc}

\newcommand{\textover}[3][l]{%
 % #1 is the alignment, default l
 % #2 is the text to be printed
 % #3 is the text for setting the width
 \makebox[\widthof{#3}][#1]{#2}%
}

\hyphenation{Isa-belle}

% % LuaLatex on Arxiv: https://tex.stackexchange.com/questions/372154/lualatex-how-to-produce-pdf-acceptable-by-arxiv 
% \hypersetup{%
%   pdfcreator = {},
%   pdfproducer = {}
% }
% \pdfvariable suppressoptionalinfo \numexpr 1+2+4+8+16+32+64+128+256+512 \relax

\usepackage{todonotes}

% Commands
\newcommand{\MLSS}{\textbf{MLSS}}

\newlength{\trianglewidth}
\settowidth{\trianglewidth}{\(\triangleleft\)}
\newcommand{\lefttrianglebar}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle; \draw (0, 0.75ex) -- (1ex, 0.75ex);}}}
\newcommand{\lefttriangle}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle;}}}

\newcommand{\lexpands}[2]{#1 $\lefttriangle$ #2}
\newcommand{\fexpands}[2]{#1 $\lefttrianglebar$ #2}
\newcommand{\fexpandsW}[2]{#1 $\lefttrianglebar_\text{v}$ #2}
\newcommand{\expandss}[2]{#1 $\lefttriangle^*$ #2}

\newcommand{\unionS}{\sqcup_\text{s}}
\newcommand{\interS}{\sqcap_\text{s}}
\newcommand{\diffS}{-_\text{s}}
\newcommand{\inS}{\in_\text{s}}
\newcommand{\notinS}{\notin_\text{s}}
\newcommand{\eqS}{=_\text{s}}
\newcommand{\neqS}{\neq_\text{s}}
\newcommand{\subseteqS}{\sqsubseteq_\text{s}}
\newcommand{\Ist}{I$_\text{st}$}
\newcommand{\Isa}{I$_\text{sa}$}

\newcommand{\fmAnd}[2]{#1 $\boldsymbol{\land}$ #2}
\newcommand{\fmOr}[2]{#1 $\boldsymbol{\lor}$ #2}
\newcommand{\fmNeg}[1]{$\boldsymbol{\neg}$ #1}
\newcommand{\fmAtom}{\textbf{A}}

\begin{document}

\setcounter{tocdepth}{1}

\title{Towards a Verified Tableau Prover for Multi-Level-Syllogistics}
\author{Lukas Stevens}
\orcid{0000-0003-0222-6858}
\affiliation{%
  \institution{Technical University of Munich}
  \department{Department of Informatics}
  \streetaddress{Boltzmannstr. 3}
  \city{Garching}
  \postcode{85748}
  \country{Germany}
}
\email{lukas.stevens@in.tum.de}

\begin{abstract}
  \todo[inline]{Write the abstract}
\end{abstract}

\maketitle

\listoftodos{}

\section{Introduction}
\todo[inline]{Write the introduction, Remember that \MLSS{} is multi-level syllogistics with singleton}

\subsection{Related work}
AFP entry~\cite{hybrid_logic_afp} and workshop paper in Isabelle 2022 workshop.

\subsection{Contributions}
\todo[inline]{Write the contributions}

\subsection{Notation}
Isabelle/HOL~\cite{isabelle} conforms to everyday mathematical notation for the most part.
For the benefit of the reader that is unfamiliar with Isabelle/HOL, we establish notation and in particular some essential datatypes together with their primitive operations that are specific to Isabelle/HOL.
We write \lstinline!t :: 'a! to specify that the term \lstinline!t! has the type \lstinline!'a! and \lstinline!'a $\Rightarrow$ 'b! for the type of a total function from \lstinline!'a! to \lstinline!'b!.
The types for booleans, natural numbers, and in integers are \lstinline!bool!, \lstinline!nat!, and \lstinline!int!, respectively.
Sets with elements of type \lstinline!'a! have the type \lstinline!'a set!.
Analogously, we use \lstinline!'a list! to describe lists, which are constructed as the empty list \lstinline![]! or with the infix constructor \lstinline!#!, and are appended with the infix operator \lstinline!@!.
The function \lstinline!set! converts a list into a set.
For optional values, Isabelle/HOL offers the type \lstinline!option! where a term \lstinline!opt :: 'a option! is either \lstinline!None! or \lstinline!Some a! with \lstinline!a :: 'a!.
Finally, we remark that \textbf{iff} is equivalent to \lstinline!$=$! on type \lstinline!bool! and \lstinline!$\equiv$! is definitional equality of the meta-logic of Isabelle/HOL, which is called Isabelle/Pure.
\todo[inline]{Add arrows and bracket notation for Pure formulae}
\section{Syntax and Semantics of MLSS\label{sec:semantics}}
\subsection{Syntax}
At the heart of \MLSS{}, we have the type of set terms which includes the empty set and variables as well as the operations union, intersection, set difference, and \lstinline!Single!, which represents a singleton set containing the argument.
\todo[inline]{Syntax for \lstinline!Single!?, overloading of \lstinline!vars_term!, \lstinline!vars_atom!}
\begin{lstlisting}
datatype (vars: 'a) pset_term =
  $\emptyset$ | Var 'a | Single ('a pset_term)
| 'a pset_term $\unionS$ 'a pset_term
| 'a pset_term $\interS$ 'a pset_term
| 'a pset_term $\diffS$ 'a pset_term
\end{lstlisting}
We can combine two set terms to form a set atom by using the membership or the equality operator.
\begin{lstlisting}
datatype (vars: 'a) pset_atom =
  'a pset_term $\inS$ 'a pset_term
| 'a pset_term $\eqS$ 'a pset_term
\end{lstlisting}
With the above operators we can also represent the subset operator \lstinline!$\subseteqS$! and enumerate finite sets as \lstinline!s $\subseteqS$ t! is equivalent to \lstinline!s $\unionS$ t $\eqS$ t! and a finite set of elements \lstinline!{t$_1$,t$_2$,$\ldots$,t$_k$}! can be expressed by \lstinline!Single t$_1$ $\unionS$ $\ldots$ $\unionS$ Single t$_k$!.

The unquantified fragment \MLSS{} of set theory is then formed by combining set atoms, which are injected into formulae with the constructor \lstinline!&\fmAtom&!, with propositional logical connectives.
\todo[inline]{Cite Nipkow's Linear Quantifier Elimination?}
\begin{lstlisting}
datatype (atoms: 'a) fm =
  &\fmAtom& 'a | &\fmNeg{('a fm)}&
| &\fmAnd{'a fm}{'a fm}& | &\fmOr{'a fm}{'a fm}&

type_synonym 'a pset_fm = 'a pset_atom fm
\end{lstlisting}
We will sometimes drop the \lstinline!Atom! constructor to reduce clutter.
Additionally, we use the abbreviations \lstinline!s $\notinS$ t! and \lstinline!s $\neqS$ t! to denote \lstinline!&\fmNeg{\fmAtom{} (s $\inS$ t)}&! and \lstinline!&\fmNeg{\fmAtom{} (s $\eqS$ t)}&!, respectively.
Note that Isabelle's datatype package automatically defines a function \lstinline!atoms :: 'a fm $\Rightarrow$ 'a set! that allows us to obtain all set atoms in a formula.
We combine these functions in order to define \lstinline!vars! that extracts all the variable names occuring in a set formula.
\todo[inline]{Motivation: one rule introduces new variables, Mention vars polymorphic}
\begin{lstlisting}
definition vars :: 'a pset_fm $\Rightarrow$ 'a set where
  vars $\phi$ $\equiv$ $\bigcup$(vars ` atoms $\phi$)
\end{lstlisting}
In addition to the variable names that appear in a formula, we will later also need to obtain those set terms that occur as subterms in a formula. 
We first define a function that collects the subterms of a set term.
\todo[inline]{Motivation: linear rules don't introduce subterms, \lstinline!subterms b $\approx$ subterms (last b)!}
\begin{lstlisting}
fun subterms :: 'a pset_term $\Rightarrow$ 'a pset_term set
where
  subterms $\emptyset$ = {$\emptyset$}
| subterms (Var x) = {Var x}
| subterms (s $\unionS$ t) =
    {s $\unionS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\interS$ t) =
    {s $\interS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\diffS$ t) =
    {s $\diffS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (Single t) =
    {Single t} $\cup$ subterms t
\end{lstlisting}
The subterms of an atom are then the subterms of those terms that make up the atom.
\begin{lstlisting}
fun subterms :: 'a pset_atom $\Rightarrow$ 'a pset_term set
where
  subterms (s $\inS$ t) = subterms s $\cup$ subterms t
| subterms (s $\eqS$ t) = subterms s $\cup$ subterms t
\end{lstlisting}
Ultimately, we lift this to formulae by using \lstinline!atoms! again.
\begin{lstlisting}
definition subterms ::
    'a pset_fm $\Rightarrow$ 'a pset_term set where
  subterms $\phi$ $\equiv$ $\bigcup$(subterms ` atoms $\phi$)
\end{lstlisting}
The last function that we define computes the subformulae of a formula.
\begin{lstlisting}
fun subfms :: 'a fm $\Rightarrow$ 'a fm set where
  subfms (&\fmAtom& a) = {&\fmAtom& a}
| subfms (&\fmAnd{p}{q}&) =
    {&\fmAnd{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmOr{p}{q}&) =
    {&\fmOr{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmNeg{q}&) = {&\fmNeg{q}&} $\cup$ subfms q
\end{lstlisting}

\subsection{Semantics}
Formulae in \MLSS{} contain arbitrarily nested set terms.
We account for this arbitrary nesting by basing the semantics on the von Neumann hierarchy $\mathcal{V}$ of sets that is defined inductively as
\todo[inline]{Simplify definition by deleting cases?}
  \[
    \begin{array}{rclr}
      \mathcal{V}_0 & = & \emptyset, \\
      \mathcal{V}_{\alpha + 1} & = & \mathcal{P}(\mathcal{V}_\alpha) & \text{for each ordinal $\alpha$}, \\
      \mathcal{V}_{\lambda} & = & \bigcup_{\mu < \lambda} \mathcal{V}_\mu & \text{for each limit ordinal $\lambda$}, \\
      \mathcal{V} & = & \bigcup_\alpha \mathcal{V}_\alpha, \\
    \end{array}
  \]
where $\mathcal{P}(S)$ is the powerset of $S$.
The sets in $\mathcal{V}$ are well-founded meaning that there can be no membership cycle in $\mathcal{V}$.

In Isabelle/HOL, which is simply typed, this definition is not accepted, though.
A way to work around this limitiation is provided by Lawrence in an AFP entry~\cite{zfc_in_hol_afp}, which adds $\mathcal{V}$ to Isabelle/HOL by way of axiomatisation.
An article by Lawrence~\cite{zfc_in_hol} provides some further context to this entry.
The entry declares a type \lstinline!V! that is equipped with a function \lstinline!elts :: V $\Rightarrow$ V set! that maps a set to its elements.
\todo[inline]{Use itemize for different functions}
Even though we use the typed sets provided by Isabelle/HOL here, \lstinline!elts! actually returns a class.
Only if the class is small enough, as indicated by the polymorphic predicate \lstinline!small :: 'a set $\Rightarrow$ bool!, it is indeed a set.
Inversely, this predicate characterises those sets that can be turned into a set of type \lstinline!V! using the polymorphic function \lstinline!vset :: 'a set $\Rightarrow$ V!.
The type \lstinline!V! comes with all the usual set operations such as equality ($=$), union ($\sqcup$), intersection ($\sqcap$), and difference ($-$).
The empty set coincides with the ordinal $0$ so it is denoted by \lstinline!0 :: V!.

Equipped with the above, we define the interpretation function \lstinline!&\Ist&! for set terms that interprets a set term with respect to a valuation function \lstinline!M :: 'a $\Rightarrow$ V! for variable.
\begin{lstlisting}
fun &\Ist& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_term $\Rightarrow$ V where
  &\Ist& M $\emptyset$ = 0
| &\Ist& M (Var x) = M x
| &\Ist& M (Single s) = vset {&\Ist& M s}
| &\Ist& M (s $\unionS$ t) = &\Ist& M s $\sqcup$ &\Ist& M t 
| &\Ist& M (s $\interS$ t) = &\Ist& M s $\sqcap$ &\Ist& M t 
| &\Ist& M (s $\diffS$ t) = &\Ist& M s $-$ &\Ist& M t 
\end{lstlisting}
The interpretation function \lstinline!I$_\text{sa}$! for set atoms is straightforward as well.
\begin{lstlisting}
fun &\Isa& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_atom $\Rightarrow$ bool
where
  &\Isa& M (s $\inS$ t) $\longleftrightarrow$ &\Ist& M s $\in$ elts (&\Ist& M t)
| &\Isa& M (s $\eqS$ t) $\longleftrightarrow$ &\Ist& M s = &\Ist& M t
\end{lstlisting}
For formulae, we write \lstinline!M $\models$ $\phi$! for the judgement that $\phi$ holds under the valuation function \lstinline!M!.
We omit the implementation of $\models$ for brevity.
\todo[inline]{Add implementation? Add satisfiability!}

\section{A Tableau Calculus for MLSS}
We formalise the tableau calculus for \MLSS{} as described by \citeauthor{new_fast_tableau}~\cite{new_fast_tableau}.
Inspired by the formalisation of a tableau calculus for Hybrid Logic by \citeauthor{hybrid_logic_afp}~\cite{hybrid_logic_afp}, we simply use a list to represent a branch of the tableau tree.
Note that formulae are added to the front of the list during branch expansion so \lstinline!last b! for a branch \lstinline!b! is always the formula that we are trying to disprove with the tableau. 
\begin{lstlisting}
type_synonym 'a branch = 'a pset_fm list
\end{lstlisting}
We now lift the functions that extract the variables respectively subterms of formulae to branches.
\begin{lstlisting}
definition subterms ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms b $\equiv$ $\bigcup$(subterms ` set b)

definition vars :: 'a branch $\Rightarrow$ 'a set 
  vars b $\equiv$ $\bigcup$(vars ` set b)
\end{lstlisting}
In the standard tableau calculus for propositional logic, a branch is called \textit{closed} if it contains both the negation of a formula and the formula itself;
conversely, it is called \textit{open} if it is not closed.
For \MLSS{}, we extend the notion of closedness with three additional rules; the first two are straightforward while the last one states that a branch is closed when the branch contains a membership cycle
\begin{center}
\lstinline!s $\inS$ t$_\text{1}$, t$_\text{1}$ $\inS$ t$_\text{2}$, $\ldots$, t$_\text{k}$ $\inS$ s!.
\end{center}
\begin{lstlisting}
inductive bclosed :: 'a branch $\Rightarrow$ bool where
  $\llbracket$ $\phi$ $\in$ set b; &\fmNeg{$\phi$}& $\in$ set b $\rrbracket$ $\Longrightarrow$ bclosed b
| (t $\inS$ $\emptyset$) $\in$ set b $\Longrightarrow$ bclosed b
| (t $\neqS$ t) $\in$ set b $\Longrightarrow$ bclosed b
| $\llbracket$ member_cycle cs; set cs $\subseteq$ set b$\rrbracket$
    $\Longrightarrow$ bclosed b

abbreviation bopen b $\equiv$ $\neg$ bclosed b
\end{lstlisting}
A tableau is called \textit{closed} if all of its branches are closed.
\todo[inline]{Move closed}

\subsection{Linear Expansion Rules}
The calculus considers two kinds of branch expansion rules: \textit{linear} and \textit{branching} rules.
As the name suggests, branching rules lead to the creation of new branches in the tableau while linear rules only extend a branch \lstinline!b! with new formulae \lstinline[breaklines=true]!b' = [$\psi_1$,$\ldots$,$\psi_n$]!, which we denote by \lstinline!&\lexpands{b'}{b}&!.
Furthermore, linear rules are restricted such that no new subterm may be created by their application:
for example, the rule
\begin{center}
\lstinline!(s $\inS$ t$_\text{1}$) $\in$ set b $\Longrightarrow$ &\lexpands{[s $\inS$ t$_\text{1}$ $\unionS$ t$_\text{2}$]}{b}&!
\end{center}
may only be used under the condition
\begin{center}
  \lstinline!t$_\text{1}$ $\unionS$ t$_\text{2}$ $\in$ subterms (last b)!.
\end{center}
\todo[inline]{Explain this restriction in more detail.}
This ensures that repeated application of linear rules eventually results in a \textit{linearly saturated} branch, i.e.\ a branch where no application of linear rules would produce new formulae.
In Isabelle, we express this as follows.
\begin{lstlisting}
definition lin_sat b $\equiv$
  $\forall$b'. &\lexpands{b'}{b}& $\longrightarrow$ set b' $\subseteq$ set b
\end{lstlisting}
\todo[inline]{Reference figure and mention missing rule + example}

\subsection{Branching Rules\label{sec:branching}}
Since the number of branches increases when applying branching rules, it is prudent to only apply them to open, linearly saturated branches.
To further prevent unnecessary branching, each rule has a \textit{subsumption} condition. 
Note that even branching rules are restricted such that they never create new subterms, with exception of the last rule which adds a fresh variable.
\todo[inline]{Reference figure}


\begin{lstlisting}
definition sat b $\equiv$ lin_sat b $\land$ ($\nexists$bs'. &\fexpands{bs'}{b}&)
\end{lstlisting}

\section{Completeness of the Calculus}
Once a branch \lstinline!b! is saturated and open at the same time, we are unable to expand the branch further in our calculus.
Thus, to establish completeness of the calculus, we must construct a model \lstinline!M! such that \lstinline!M $\models$ $\phi$! for all formulae \lstinline!$\phi$ $\in$ set b!.
The model is defined in terms of the following three collections.
\todo[inline]{explain wits, explain that wits' are those whose value is not fixed by literals in b}
\begin{lstlisting}
definition wits :: 'a branch $\Rightarrow$ 'a set where
  wits b $\equiv$ vars b - vars (last b)

definition wits' :: 'a branch $\Rightarrow$ 'a set where
  wits' b $\equiv$
    {c $\in$ wits b. $\forall$t $\in$ subterms (last b).
      AT (Var c $\eqS$ t) $\notin$ set b $\land$
      AT (t $\eqS$ Var c) $\notin$ set b} 

definition subterms' ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms' b $\equiv$
    subterms (last b) $\cup$ 
    Var ` (wits b - wits' b)
\end{lstlisting}
We aim to construct a syntactic model that is derived from the membership literals \lstinline!(s $\inS$ t) $\in$ set b!.
To this end, we construct a graph whose vertices are set terms and there is an edge from \lstinline!s! to \lstinline!t! in the graph if, and only if, \lstinline!s $\inS$ t! is in \lstinline!b!.
Note that we use \citeauthor{graph_theory_afp}'s graph library~\cite{graph_theory_afp} where a graph is represented as a record of vertices, arcs (directed edges), and two functions \lstinline!tail! and \lstinline!head! that map an arc to its source respectively target vertex.
\begin{lstlisting}
definition bgraph b $\equiv$
  let vs = Var ` wits' b $\cup$ subterms' b
  in $\llparenthesis$ verts = vs,
     &$\phantom{\llparenthesis}$& arcs = {(s, t). (s $\inS$ t) $\in$ set b},
     &$\phantom{\llparenthesis}$& tail = fst, head = snd $\rrparenthesis$
\end{lstlisting}
The model is defined in terms of a \textit{realization} function relative to this graph.
Observe that the vertices are partitioned into two sets, a collection of witnesses \lstinline!Var ` wits' b! and the rest of the set terms \lstinline!subterms' b!, which are treated differently by the realization.
Terms in the latter set are evaluated in accordance to the structure of the graph, i.e.\ the realization of a vertex is defined as the union of the realizations of the parent vertices. 
For the former set, we choose a function \lstinline!I! that assigns the witnesses in \lstinline!Var ` wits' b! pairwise distinct sets with cardinality greater than that of the vertices.
We can always choose such a function since we assume an infinite universe of variables.
Then, we return the singleton set \lstinline!vset {I x}!, which, together with the cardinality constraint, ensures that realizations are distinct between those witnesses and the set terms.  
\begin{lstlisting}
abbreviation parents G s $\equiv$ {u. u $\rightarrow_\text{G}$ s}

function realize :: 'a pset_term $\Rightarrow$ V where
  x $\in$ Var ` wits' b $\Longrightarrow$ realize x = vset {I x}
| x $\in$ subterms' b
  $\Longrightarrow$ realize t =
  &$\phantom{\Longrightarrow}$&   vset {realize ` parents (bgraph b) s}
| x $\notin$ verts G $\Longrightarrow$ realize x = 0
\end{lstlisting}
Since the function is recursive, we need to ensure that it terminates for it to be well-defined.
The assumption that \lstinline!b! is open implies that there are no membership cycles and thus \lstinline!bgraph b! is acyclic.
Now, consider the ancestors \lstinline!av! of a vertex \lstinline!v!, which are those vertices from which we can reach \lstinline!v!.
Due to acyclicity, it holds that the ancestors \lstinline!ap! of a parent \lstinline!p! of \lstinline!v! are a subset of \lstinline!av!.
They are also a proper subset of \lstinline!av! since \lstinline!p! is an ancestor of \lstinline!v! but not of \lstinline!p! itself.
Together with the fact that \lstinline!bgraph b! is finite, it follows that the cardinality of the ancestors decreases in each recursive call thus proving the termination of \lstinline!realize!.
\todo[inline]{Ãœberleitung}

\subsection{Formalising the Key Technical Lemma}
\begin{lstlisting}
fun is_literal :: 'a fm $\Rightarrow$ bool where
  is_literal (&\fmAtom& _) = True
| is_literal (&\fmNeg{(\fmAtom{} \_)}&) = True
| is_literal _ = False
\end{lstlisting}

\todo[inline]{Rename \lstinline!lemma_2!}
\begin{lstlisting}
lemma lemma_2:
  assumes wf_branch b
  assumes c $\in$ wits' b and t $\in$ subterms b
  shows (Var c $\eqS$ t) $\notin$ set b
    and (t $\eqS$ Var c) $\notin$ set b
    and (t $\inS$ Var c) $\notin$ set b
\end{lstlisting}
Only one quite trivial invariant needed 


\begin{lstlisting}
definition no_new_subterms b $\equiv$
  $\forall$t $\in$ subterms b. t $\notin$ Var ` wits b
    $\longrightarrow$ t $\in$ subterms (last b))
\end{lstlisting}

\begin{lstlisting}
definition wf_branch b $\equiv$ $\exists$$\phi$. &\expandss{b}{[$\phi$]}&
\end{lstlisting}


\subsection{Realisation of an Open Branch}
Remember that for completeness, we need to show that the realization function for an open and saturated branch \lstinline!b! actually constitutes a model for all formualae in the branch.
We start by verifying that the realization function models all literals in the branch; more formally, the following propositions hold: 
\begin{enumerate}[label=(\roman*)]
  \item\label{it:at_mem} We have \lstinline!realize s $\in$ elts (realize t)! if it holds that \lstinline!s $\inS$ t! is in \lstinline!b!. 
  \item\label{it:at_eq} We have \lstinline!realize s $=$ realize t! if \lstinline!s $\eqS$ t! is in \lstinline!b!.
  \item\label{it:af_eq} We have \lstinline!realize s $\neq$ realize t! if \lstinline!s $\neqS$ t! is in \lstinline!b!.
  \item\label{it:af_mem} We have \lstinline!realize s $\notin$ elts (realize t)! if it holds that \lstinline!s $\notinS$ t! is in \lstinline!b!. 
\end{enumerate}
To illustrate the usefulness of \lstinline!lemma_2!, we prove Proposition~\ref{it:at_eq}.
The proofs of all propositions translate well into Isabelle so we refer to the original paper~\cite{new_fast_tableau} for the remaining proofs. 
\begin{proof}[Proof of Proposition~\ref{it:at_eq}]
  Assume that \lstinline!s $\eqS$ t! is in \lstinline!b!.
  If there exists a \lstinline!c $\in$ wits' b! where \lstinline!s = Var c! or \lstinline!t = Var c!, we arrive at a contradiction due to \lstinline!lemma_2!.
  Therefore, both \lstinline!s $\in$ subterms' b! and \lstinline!t $\inS$ subterms' b! must hold.
  Now, assume for contradiction that \lstinline!realize s $\neq$ realize t! which implies that \lstinline!elts (realize s) $\neq$ elts (realize t)!.
  Without loss of generality --- the other case is symmetric ---, we obtain an \lstinline!a! such that
\begin{lstlisting}
  a $\in$ elts (realize s) $\land$ a $\notin$ elts (realize t). 
\end{lstlisting}
  Considering the fact that \lstinline!s $\in$ subterms' b! and the definition of \lstinline!realize!, we obtain an \lstinline!u! such that \lstinline!a = realize u! and \lstinline!u $\rightarrow_\text{bgraph b}$ s!.
  This, in turn, yields that \lstinline!u $\inS$ s! must be in \lstinline!b!.
  Together with the assumption \lstinline!(s $\eqS$ t) $\in$ b! and the openness of \lstinline!b!, it follows that \lstinline!u $\inS$ t! must also be in \lstinline!b!.
  But then we have
\begin{lstlisting}[columns=fixed]
  realize u $\in$ elts (realize t)
        = a $\in$ elts (realize t)
\end{lstlisting}
  using Proposition~\ref{it:at_mem}, which stands in contradiction to the assumption \lstinline!a $\notin$ elts (realize t)!.
\end{proof}

\noindent The results on literals can now be lowered to set terms.
\begin{enumerate}[label=(\alph*)]
  \item\label{it:empty} If \lstinline!$\emptyset$ $\in$ subterms b!, then \lstinline!realize $\emptyset$ = 0!.
  \item\label{it:op} Let \lstinline!$\star_\text{s}$ $\in$ {$\unionS$, $\diffS$, $\interS$}!. If the term \lstinline!s $\star_\text{s}$ t! occurs in \lstinline!subterms b!, then
    \begin{center}
    \lstinline!realize (s $\star_\text{s}$ t) = realize s $\star$ realize t!.
    \end{center}
  \item\label{it:single} If \lstinline!Single t $\in$ subterms b!, then
    \begin{center}
    \lstinline!realize (Single t) = vset {realize t}!.
    \end{center}
\end{enumerate}
\begin{proof}[Proof of Proposition~\ref{it:empty}]
  Since \lstinline!b! is open, we know \lstinline!s $\inS$ $\emptyset$! is not in \lstinline!b! for any \lstinline!s!, implying that the term \lstinline!$\emptyset$! has no parents in \lstinline!bgraph b!.
  Moreover, the assumption \lstinline!$\emptyset$ $\in$ subterms b! can be strengthened to \lstinline!$\emptyset$ $\in$ subterms' b! as the term \lstinline!$\emptyset$! is not a witness. 
  Ultimately, we obtain \lstinline!realize $\emptyset$ = 0! by definition of \lstinline!realize!.
\end{proof}
\begin{proof}[Proof of Proposition~\ref{it:op} for $\star_\texttt{s} = -_\texttt{s}$]
  For equality, it suffices to prove subset inclusion in both directions.

  \textbf{Direction $\subseteq$. } Fix some \lstinline!e! in \lstinline!elts (realize (s $\diffS$ t))!.
  Again, we obtain an \lstinline!u! with 
\begin{lstlisting}
  e = realize u $\land$ u $\rightarrow_\text{bgraph b}$ (s $\diffS$ t).
\end{lstlisting}
  We therefore have \lstinline!(u $\inS$ s $\diffS$ t) $\in$ set b! which, due to \lstinline!b! being saturated, implies that \lstinline!u $\inS$ s! is in \lstinline!b! while \lstinline!u $\inS$ t! is not.
  By applying Proposition~\ref{it:at_mem} and~\ref{it:af_mem} we obtain
\begin{lstlisting}
  realize u $\in$ realize s $\land$ realize u $\notin$ realize t
\end{lstlisting}
  and together with \lstinline!e = realize u! we arrive at the goal 
\begin{lstlisting}
  e $\in$ elts (realize s - realize t).
\end{lstlisting}

\textbf{Direction $\supseteq$. } Let \lstinline[columns=fullflexible]!e $\in$ elts (realize s - realize t)! for some fixed \lstinline!e!.
  As before, we obtain an \lstinline!u! such that \lstinline!e! is the realization of \lstinline!u!, i.e.\ \lstinline!e = realization u!, and
\begin{lstlisting}
  u $\rightarrow_\text{bgraph b}$ s $\land$ u $\nrightarrow_\text{bgraph b}$ t.
\end{lstlisting}
  An immediate consequence is that \lstinline!u $\inS$ s! is in \lstinline!b!.
  Moreover, we claim that \lstinline!u $\notinS$ t! is also in \lstinline!b!.
  To see that this is true, recall that \lstinline!b! is saturated and thus the subsumption condition of rule TODO needs to hold.
  This implies that either \lstinline!u $\inS$ t! or \lstinline!u $\notinS$ t! is in \lstinline!b! but the latter being in \lstinline!b! would be a contradiction to \lstinline!u $\nrightarrow_\text{bgraph b}$ t! meaning that the former must hold.
  Ultimately, we infer that \lstinline!u $\in$ s $\diffS$ t! is in \lstinline!b! by invoking saturation again.
  The last step is to apply Proposition~\ref{it:at_mem} in order to obtain the goal
  \begin{lstlisting}
    realize u $\in$ elts (realize (s $\diffS$ t))
    &\textover[r]{=}{realize}& e $\in$ elts (realize (s $\diffS$ t)).
  \end{lstlisting}
\end{proof}

\noindent The final step towards obtaining a proper model is to connect the realization function to the semantics as defined in Section~\ref{sec:semantics}.
For set terms, we can use the Propositions~\ref{it:empty}--\ref{it:single} to prove the lemma below by induction.
\begin{lstlisting}
lemma
  assumes t $\in$ subterms b
  shows &\Ist& ($\lambda$x. realize (Var x)) t = realize t
\end{lstlisting}
Lifting the above result to formulae yields the coherence of \lstinline!b! as the original paper~\cite{new_fast_tableau} calls it.
The proof is a tedious but straightforward induction on the the size of the formulae.
\begin{lstlisting}
lemma coherence:
  assumes $\phi$ $\in$ set b
  shows ($\lambda$x. realize (Var x)) $\models$ $\phi$
\end{lstlisting}
The coherence property finishes the proof of completeness of the calculus as it gives us a model for every formula in an open and saturated branch.

\section{Soundness of the Calculus}
Two aspects determine the soundness of the calculus: a closed branch must be unsatisfiable and all expansion rules must maintain satisfiability.
We can express the former aspect in Isabelle as follows.
\begin{lstlisting}[belowskip=0pt]
lemma bclosed_sound:
  assumes bclosed b shows $\exists$$\phi$ $\in$ set b. M $\not\models$ $\phi$
\end{lstlisting}
\begin{proof}
  Assume for contradiction that \lstinline!b! is closed but we have a model, i.e.\ it holds that \lstinline!$\forall$$\phi$ $\in$ set b. M $\models$ $\phi$!.
  We perform a case analysis on \lstinline!bclosed b!.
  It is clear that, for any \lstinline!s!, neither does \lstinline!M! model \lstinline!s $\in$ $\emptyset$! nor \lstinline!s $\neqS$ s!.
  Furthermore, no model can satisfy both \lstinline!$\phi$! and \lstinline!&\fmNeg{$\phi$}&! at the same time.
  This leaves us with the case where \lstinline!b! contains a membership cycle
\begin{lstlisting}
  t$_\text{0}$ $\inS$ t$_\text{1}$, t$_\text{1}$ $\inS$ t$_\text{2}$, $\ldots$, t$_\text{k}$ $\inS$ t$_\text{0}$.
\end{lstlisting}
  By assumption, each atom of the membership cycle holds under the model \lstinline!M!; in other words, we have
\begin{lstlisting}
  &\Ist& M t$_\text{i}$ $\in$ elts (&\Ist& M t$_\text{i + 1 mod k + 1}$)
\end{lstlisting}
  for each \lstinline!i $\in$ {0,$\ldots$,k}!.
  Therefore, the transitive closure of the membership relation \lstinline!{(x, y). x $\in$ elts y}! contains a cycle. 
  This, however, is a contradiction since the membership relation of \lstinline!V! is well-founded (see Section~\ref{sec:semantics}) and well-foundedness is closed under transitive closure.
\end{proof}

\noindent We are left with showing that both linear and branching expansion rules preserve satisfiability.
As for the linear rules, a straightforward proof by rule induction suffices to obtain the lemma below.
\begin{lstlisting}
lemma lexpands_sound:
  assumes &\lexpands{b'}{b}& and $\phi$ $\in$ set b'
  assumes $\bigwedge$$\psi$. $\psi$ $\in$ set b $\Longrightarrow$ M $\models$ $\psi$
  shows M $\models$ $\phi$
\end{lstlisting}
A similar argument would work for the branching rules if it were not for the last rule adding new variables.
Those variables need to be assigned specific values, hence modifying the model, as we will see in the proof below.
\begin{lstlisting}[belowskip=0pt]
lemma fexpands_sound:
  assumes &\fexpands{bs'}{b}&
  assumes $\bigwedge$$\psi$. $\psi$ $\in$ set b $\Longrightarrow$ M $\models$ $\psi$
  shows $\exists$M'. $\exists$b' $\in$ bs'.
          $\forall$$\psi$ $\in$ set (b' @ b). M' $\models$ $\psi$
\end{lstlisting}
\begin{proof}
  We perform a case analysis on the derivation \lstinline!&\fexpands{bs'}{b}&!.
  As all cases but that of the last rule are straightforward, we only consider this last case where we have 
\begin{lstlisting}
  bs' = {[Var x $\inS$ s, Var x $\notinS$ t],
         [Var x $\inS$ t, Var x $\notinS$ s]}
\end{lstlisting}
  for some fresh variable \lstinline!x!, i.e.\ \lstinline!x $\notin$ vars b! and in particular \lstinline!x $\notin$ vars s $\cup$ vars t!.
  Another consequence of applying the last rule is that \lstinline!s $\neqS$ t! is in \lstinline!b!, which, because \lstinline!M! is a model, implies that \lstinline!&\Ist& M s $\neq$ &\Ist& M t!.
  This inequality manifests itself through some \lstinline!y! with
\begin{lstlisting}
  &\phantom{$\lor$}& y $\in$ elts (&\Ist& M s) $\land$ y $\notin$ elts (&\Ist& M t)
  $\lor$ y $\in$ elts (&\Ist& M t) $\land$ y $\notin$ elts (&\Ist& M s).
\end{lstlisting}
  We now update the assignment \lstinline!M! such that it maps \lstinline!x! to \lstinline!y! to obtain the assignment \lstinline!M'!.
  Note that values of both \lstinline!s! and \lstinline!t! are unchanged under this update as \lstinline!x $\notin$ vars s! and \lstinline!x $\notin$ vars t!.
  Considering our assumption about \lstinline!y! and the fact that \lstinline!&\Ist& M' (Var x) = y!, we infer that
\begin{lstlisting}
  $\exists$b' $\in$ bs'. $\forall$$\psi$ $\in$ set b'. M' $\models$ $\psi$.
\end{lstlisting}
  In other words, due to the disjunction, it holds that \lstinline!M'! is a model for one \lstinline!b' $\in$ bs!.
  Thus, we are left with proving that \lstinline!M'! is a model for \lstinline!b!.
  This is indeed the case since the assumption \lstinline!M $\models$ $\psi$! is equivalent to \lstinline!M' $\models$ $\psi$! for all \lstinline!$\psi$ $\in$ set b! given that \lstinline!x! is fresh with respect to b.
\end{proof}

\section{Upper Bounding the Cardinality of a Branch}
Soundness and completeness of the calculus are the building blocks with which we establish partial correctness of Algorithm~\ref{fig:alg}.
Consequently, we still need to give a termination proof of Algorithm~\ref{fig:alg} to obtain total correctness of the algorithm.
The core of our argument is that the number of distinct formulae in a branch that can be derived with the expansion rules is finite.
In particular, we claim that the number of distinct formulae has the following upper bound.
\begin{lstlisting}
  &\phantom{$\leq$}& card (set b)
  &\textover{$=$}{$\leq$}& card {$\psi$ $\in$ set b. $\neg$ is_literal $\psi$} +
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. is_literal $\psi$}
  $\leq$ 2 * card (subfms (last b)) +
  &\phantom{$\leq$}& card {$\psi$ $\in$ set b. is_literal $\psi$}
  $\leq$ 2 * card (subfms (last b)) +
  &\phantom{$\leq$}& 16 * (card (subterms (last b)))$^4$
\end{lstlisting}
We justify both inequalities separately, starting with the first one whose justification hinges on an invariant:
Its justification hinges on the invariant that the only new subformulae introduced by the expansion rules introduce


\section{An Abstract Specification of the Decision Procedure}
\begin{figure*}
  \centering
\begin{lstlisting}
function mlss_proc_branch :: 'a branch $\Rightarrow$ bool where
  $\neg$ lin_sat b
  $\Longrightarrow$ mlss_proc_branch = mlss_proc_branch ((SOME b'. &\lexpands{b'}{b}& $\land$ set b $\subset$ set (b' @ b)) @ b)
| $\llbracket$ $\neg$ sat b; bopen b; lin_sat b $\rrbracket$
  $\Longrightarrow$ mlss_proc_branch b = ($\forall$b' $\in$ (SOME bs. &\fexpands{bs}{b}&). mlss_proc_branch (b' @ b))
| $\llbracket$ lin_sat b; sat b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = bclosed b
| $\llbracket$ lin_sat b; bclosed b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = True

definition mlss_proc :: 'a pset_fm $\Rightarrow$ bool where
  mlss_proc $\phi$ $\equiv$ mlss_proc_branch [$\phi$]
\end{lstlisting}
\caption{Definition of the functions \lstinline|mlss_proc_branch| and \lstinline|mlss_proc|.\label{fig:alg}}
\end{figure*}

\section{Future Work}
Challenges in obtaining an executable specification: membership cycle test unnecessary, fast branch membership test, proof reconstruction.
Additional constructs such as finiteness and pairs.
Optimisations for the algorithm.

\section{Conclusion}
\todo[inline]{Conclude}

\begin{acks}
  \todo[inline]{Acknowledge}
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sources}

\end{document}
