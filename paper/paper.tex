\documentclass[sigplan,10pt,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[british]{babel}

\usepackage{mathpartir}

%\usepackage{unicode-math}
%\setmathfont{latinmodern-math.otf}
%\setmathfont[version=bold, FakeBold=2]{latinmodern-math.otf}

\usepackage{xcolor}

\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}

\usepackage{enumitem}

\setlength{\abovecaptionskip}{0pt}
\setlength{\textfloatsep}{18pt plus 2pt minus 4pt}

\usepackage{listings}
\definecolor{isarblue}{HTML}{006699}
\definecolor{isargreen}{HTML}{009966}
\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,function,abbreviation,definition,proof,lemma,theorem,corollary,inductive},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=fixed,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}
\makeatletter
\lst@AddToHook{OnEmptyLine}{\vspace{-0.4\baselineskip}}
\makeatother
% This is a hack to allow escaping inside lstinline (https://tex.stackexchange.com/questions/43526/escaping-in-lstinline)
\usepackage{etoolbox}
\makeatletter
\patchcmd{\lsthk@TextStyle}{\let\lst@DefEsc\@empty}{}{}{\errmessage{failed to patch}}
\makeatother

\usepackage{calc}

\newcommand{\textover}[3][l]{%
 % #1 is the alignment, default l
 % #2 is the text to be printed
 % #3 is the text for setting the width
 \makebox[\widthof{#3}][#1]{#2}%
}

\hyphenation{Isa-belle}

% % LuaLatex on Arxiv: https://tex.stackexchange.com/questions/372154/lualatex-how-to-produce-pdf-acceptable-by-arxiv 
% \hypersetup{%
%   pdfcreator = {},
%   pdfproducer = {}
% }
% \pdfvariable suppressoptionalinfo \numexpr 1+2+4+8+16+32+64+128+256+512 \relax

\usepackage{todonotes}

% Commands
\newcommand{\MLSS}{\textbf{MLSS}}
\newlength{\trianglewidth}
\settowidth{\trianglewidth}{\(\triangleleft\)}

\newcommand{\lefttrianglebar}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle; \draw (0, 0.75ex) -- (1ex, 0.75ex);}}}
\newcommand{\lefttriangle}{\mathrel{\tikz[baseline]{\draw (1ex, 0.75ex) -- (0, 1.25ex) -- (0, 0.25ex) -- cycle;}}}

\newcommand{\sexpands}[2]{#1 $\lefttriangle$ #2}
\newcommand{\fexpands}[2]{#1 $\lefttrianglebar$ #2}
\newcommand{\expandss}[2]{#1 $\lefttriangle^*$ #2}


\newcommand{\unionS}{\sqcup_\text{s}}
\newcommand{\interS}{\sqcap_\text{s}}
\newcommand{\diffS}{-_\text{s}}
\newcommand{\inS}{\in_\text{s}}
\newcommand{\notinS}{\notin_\text{s}}
\newcommand{\eqS}{\approx_\text{s}}
\newcommand{\neqS}{{\not\approx}_\text{s}}
\newcommand{\subseteqS}{\sqsubseteq_\text{s}}
\newcommand{\Ist}{I$_\text{st}$}
\newcommand{\Isa}{I$_\text{sa}$}

\newcommand{\fmAnd}[2]{#1 $\boldsymbol{\land}$ #2}
\newcommand{\fmOr}[2]{#1 $\boldsymbol{\lor}$ #2}
\newcommand{\fmNeg}[1]{$\boldsymbol{\neg}$ #1}
\newcommand{\fmAtom}{\textbf{A}}

\begin{document}

\setcounter{tocdepth}{1}

\title{Towards a Verified Tableau Prover for Multi-Level-Syllogistics}
\author{Lukas Stevens}
\orcid{0000-0003-0222-6858}
\affiliation{%
  \institution{Technical University of Munich}
  \department{Department of Informatics}
  \streetaddress{Boltzmannstr. 3}
  \city{Garching}
  \postcode{85748}
  \country{Germany}
}
\email{lukas.stevens@in.tum.de}

\begin{abstract}
  \todo[inline]{Write the abstract}
\end{abstract}

\maketitle

\listoftodos{}

\section{Introduction}
\todo[inline]{Write the introduction}

\subsection{Related work}
AFP entry~\cite{hybrid_logic_afp} and workshop paper in Isabelle 2022 workshop.

\subsection{Contributions}
\todo[inline]{Write the contributions}

\subsection{Notation}
Isabelle/HOL~\cite{isabelle} conforms to everyday mathematical notation for the most part.
For the benefit of the reader that is unfamiliar with Isabelle/HOL, we establish notation and in particular some essential datatypes together with their primitive operations that are specific to Isabelle/HOL.
We write \lstinline!t :: 'a! to specify that the term \lstinline!t! has the type \lstinline!'a! and \lstinline!'a $\Rightarrow$ 'b! for the type of a total function from \lstinline!'a! to \lstinline!'b!.
The types for booleans, natural numbers, and in integers are \lstinline!bool!, \lstinline!nat!, and \lstinline!int!, respectively.
Sets with elements of type \lstinline!'a! have the type \lstinline!'a set!.
Analogously, we use \lstinline!'a list! to describe lists, which are constructed as the empty list \lstinline![]! or with the infix constructor \lstinline!#!, and are appended with the infix operator \lstinline!@!.
The function \lstinline!set! converts a list into a set.
For optional values, Isabelle/HOL offers the type \lstinline!option! where a term \lstinline!opt :: 'a option! is either \lstinline!None! or \lstinline!Some a! with \lstinline!a :: 'a!.
Finally, we remark that \textbf{iff} is equivalent to \lstinline!$=$! on type \lstinline!bool! and \lstinline!$\equiv$! is definitional equality of the meta-logic of Isabelle/HOL, which is called Isabelle/Pure.
\todo[inline]{Add arrows and bracket notation for Pure formulae}
\section{Syntax and Semantics of MLSS\label{sec:semantics}}
\subsection{Syntax}
At the heart of \MLSS{}, we have the type of set terms which includes the empty set and variables as well as the operations union, intersection, set difference, and \lstinline!Single!, which represents a singleton set containing the argument.
\todo[inline]{Syntax for \lstinline!Single!?}
\begin{lstlisting}
datatype 'a pset_term =
  $\emptyset$ | Var 'a | Single ('a pset_term)
| 'a pset_term $\unionS$ 'a pset_term
| 'a pset_term $\interS$ 'a pset_term
| 'a pset_term $\diffS$ 'a pset_term
\end{lstlisting}
We can combine two set terms to form a set atom by using the membership or the equality operator.
\begin{lstlisting}
datatype 'a pset_atom =
  'a pset_term $\inS$ 'a pset_term
| 'a pset_term $\eqS$ 'a pset_term
\end{lstlisting}
With the above operators we can also represent the subset operator \lstinline!$\subseteqS$! and enumerate finite sets as \lstinline!s $\subseteqS$ t! is equivalent to \lstinline!s $\unionS$ t $\eqS$ t! and a finite set of elements \lstinline!{t$_1$,t$_2$,$\ldots$,t$_k$}! can be expressed by \lstinline!Single t$_1$ $\unionS$ $\ldots$ $\unionS$ Single t$_k$!.

The unquantified fragment \MLSS{} of set theory is then formed by combining set atoms, which are injected into formulae with the constructor \lstinline!&\fmAtom&!, with propositional logical connectives.
\todo[inline]{Cite Nipkow's Linear Quantifier Elimination?}
\begin{lstlisting}
datatype (atoms: 'a) fm =
  &\fmAtom& 'a | &\fmNeg{('a fm)}&
| &\fmAnd{'a fm}{'a fm}& | &\fmOr{'a fm}{'a fm}&

type_synonym 'a pset_fm = 'a pset_atom fm
\end{lstlisting}
We will sometimes drop the \lstinline!Atom! constructor to reduce clutter.
Additionally, we use the abbreviations \lstinline!s $\notinS$ t! and \lstinline!s $\neqS$ t! to denote \lstinline!&\fmNeg{\fmAtom{} (s $\inS$ t)}&! and \lstinline!&\fmNeg{\fmAtom{} (s $\eqS$ t)}&!, respectively.
Note that Isabelle's datatype package automatically defines a function \lstinline!atoms :: 'a fm $\Rightarrow$ 'a set! that allows us to obtain all set atoms in a formula.
Similarly, it defines a function \lstinline!set_pset_atom :: 'a pset_atom $\Rightarrow$ 'a set! with which we can extract all the variable names in a set atom.
We combine these functions in order to define \lstinline!vars_fm! that extracts all the variable names occuring in a set formula.
\todo[inline]{Motivation: one rule introduces new variables}
\begin{lstlisting}
definition vars_fm :: 'a pset_fm $\Rightarrow$ 'a set where
  vars_fm $\phi$ $\equiv$ $\bigcup$(set_pset_atom ` atoms $\phi$)
\end{lstlisting}
In addition to the variable names that appear in a formula, we will later also need to obtain those set terms that occur as subterms in a formula. 
We first define a function that collects the subterms of a set term.
\todo[inline]{Motivation: saturating rules don't introduce subterms}
\begin{lstlisting}
fun subterms ::
    'a pset_term $\Rightarrow$ 'a pset_term set where
  subterms $\emptyset$ = {$\emptyset$}
| subterms (Var x) = {Var x}
| subterms (s $\unionS$ t) =
    {s $\unionS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\interS$ t) =
    {s $\interS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (s $\diffS$ t) =
    {s $\diffS$ t} $\cup$ subterms s $\cup$ subterms t
| subterms (Single t) =
    {Single t} $\cup$ subterms t
\end{lstlisting}
The subterms of an atom are then the subterms of those terms that make up the atom.
\begin{lstlisting}
fun subterms_atom ::
      'a pset_atom $\Rightarrow$ 'a pset_term set where
  subterms_atom (s $\inS$ t) =
    subterms s $\cup$ subterms t
| subterms_atom (s $\eqS$ t) =
    subterms s $\cup$ subterms t
\end{lstlisting}
Ultimately, we lift this to formulae by using \lstinline!atoms! again.
\begin{lstlisting}
definition subterms_fm ::
    'a pset_fm $\Rightarrow$ 'a pset_term set where
  subterms_fm $\phi$ $\equiv$ $\bigcup$(subterms_atom ` atoms $\phi$)
\end{lstlisting}
The last function that we define computes the subformulae of a formula.
\begin{lstlisting}
fun subfms :: 'a fm $\Rightarrow$ 'a fm set where
  subfms (&\fmAtom& a) = {&\fmAtom& a}
| subfms (&\fmAnd{p}{q}&) =
    {&\fmAnd{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmOr{p}{q}&) =
    {&\fmOr{p}{q}&} $\cup$ subfms p $\cup$ subfms q
| subfms (&\fmNeg{q}&) = {&\fmNeg{q}&} $\cup$ subfms q
\end{lstlisting}

\subsection{Semantics}
Formulae in \MLSS{} contain arbitrarily nested set terms.
We account for this arbitrary nesting by basing the semantics on the von Neumann hierarchy $\mathcal{V}$ of sets that is defined inductively as
\todo[inline]{Simplify definition by deleting cases?}
  \[
    \begin{array}{rclr}
      \mathcal{V}_0 & = & \emptyset, \\
      \mathcal{V}_{\alpha + 1} & = & \mathcal{P}(\mathcal{V}_\alpha) & \text{for each ordinal $\alpha$}, \\
      \mathcal{V}_{\lambda} & = & \bigcup_{\mu < \lambda} \mathcal{V}_\mu & \text{for each limit ordinal $\lambda$}, \\
      \mathcal{V} & = & \bigcup_\alpha \mathcal{V}_\alpha, \\
    \end{array}
  \]
where $\mathcal{P}(S)$ is the powerset of $S$.
The sets in $\mathcal{V}$ are well-founded meaning that there can be no membership cycle in $\mathcal{V}$.

In Isabelle/HOL, which is simply typed, this definition is not accepted, though.
A way to work around this limitiation is provided by Lawrence in an AFP entry~\cite{zfc_in_hol_afp}, which adds $\mathcal{V}$ to Isabelle/HOL by way of axiomatisation.
An article by Lawrence~\cite{zfc_in_hol} provides some further context to this entry.
The entry declares a type \lstinline!V! that is equipped with a function \lstinline!elts :: V $\Rightarrow$ V set! that maps a set to its elements.
Even though we use the typed sets provided by Isabelle/HOL here, \lstinline!elts! actually returns a class.
Only if the class is small enough, as indicated by the polymorphic predicate \lstinline!small :: 'a set $\Rightarrow$ bool!, it is indeed a set.
Inversely, this predicate characterises those sets that can be turned into a set of type \lstinline!V! using the polymorphic function \lstinline!vset :: 'a set $\Rightarrow$ V!.
The type \lstinline!V! comes with all the usual set operations such as equality ($=$), union ($\sqcup$), intersection ($\sqcap$), and difference ($-$).
The empty set coincides with the ordinal $0$ so we denote it with \lstinline!0 :: V!.

Equipped with the above, we define the interpretation function \lstinline!&\Ist&! for set terms that interprets a set term with respect to a valuation function \lstinline!M :: 'a $\Rightarrow$ V! for variable.
\begin{lstlisting}
fun &\Ist& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_term $\Rightarrow$ V where
  &\Ist& M $\emptyset$ = 0
| &\Ist& M (Var x) = M x
| &\Ist& M (Single s) = vset {&\Ist& M s}
| &\Ist& M (s $\unionS$ t) = &\Ist& M s $\sqcup$ &\Ist& M t 
| &\Ist& M (s $\interS$ t) = &\Ist& M s $\sqcap$ &\Ist& M t 
| &\Ist& M (s $\diffS$ t) = &\Ist& M s $-$ &\Ist& M t 
\end{lstlisting}
The interpretation function \lstinline!I$_\text{sa}$! for set atoms is straightforward as well.
\begin{lstlisting}
fun &\Isa& :: ('a $\Rightarrow$ V) $\Rightarrow$ 'a pset_atom $\Rightarrow$ bool
where
  &\Isa& M (s $\inS$ t) $\longleftrightarrow$ &\Ist& M s $\in$ elts (&\Ist& M t)
| &\Isa& M (s $\eqS$ t) $\longleftrightarrow$ &\Ist& M s = &\Ist& M t
\end{lstlisting}
For formulae, we write \lstinline!M $\models$ $\phi$! for the judgement that $\phi$ holds under the valuation function \lstinline!M!.
We omit the implementation of $\models$ for brevity.

\section{A Tableau Calculus for MLSS}
We formalise the tableau calculus for \MLSS{} as described by \citeauthor{new_fast_tableau}~\cite{new_fast_tableau}.
Inspired by the formalisation of a tableau calculus for Hybrid Logic by \citeauthor{hybrid_logic_afp}~\cite{hybrid_logic_afp}, we simply use a list to represent a branch of the tableau tree.
Note that formulae are added to the front of the list during branch expansion so \lstinline!last b! for a branch \lstinline!b! is always the formula that we are trying to disprove with the tableau. 
\begin{lstlisting}
type_synonym 'a branch = 'a pset_fm list
\end{lstlisting}
We now lift the functions that extract the variables respectively subterms of formulae to branches.
\begin{lstlisting}
definition subterms_branch ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms_branch b $\equiv$ $\bigcup$(subterms_fm ` set b)

definition vars_branch :: 'a branch $\Rightarrow$ 'a set 
  vars_branch b $\equiv$ $\bigcup$(vars_fm ` set b)
\end{lstlisting}
In the standard tableau calculus for propositional logic, a branch is called \textit{closed} if it contains both the negation of a formula as well as the formula itself and it is called \textit{open} if it is not closed.
We extend the notion of closedness with three additional rules; the first two are straightforward while the last one states that a branch is closed when the branch contains a membership cycle \lstinline!s $\inS$ t$_\text{1}$, t$_\text{1}$ $\inS$ t$_\text{2}$, $\ldots$, t$_\text{k}$ $\inS$ s!.
\begin{lstlisting}
inductive bclosed :: 'a branch $\Rightarrow$ bool where
  $\llbracket$ $\phi$ $\in$ set b; &\fmNeg{$\phi$}& $\in$ set b $\rrbracket$ $\Longrightarrow$ bclosed b
| (t $\inS$ $\emptyset$) $\in$ set b $\Longrightarrow$ bclosed b
| (t $\neqS$ t) $\in$ set b $\Longrightarrow$ bclosed b
| $\llbracket$ member_cycle cs; set cs $\subseteq$ set b$\rrbracket$
    $\Longrightarrow$ bclosed b

abbreviation bopen b $\equiv$ $\neg$ bclosed b
\end{lstlisting}
A tableau is called \textit{closed} if all of its branches are closed.

\subsection{Saturating Expansion Rules}
The calculus considers two kinds of expansion rules: \textit{saturating} and \textit{fulfilling}.
Whereas fulfilling expansion rules lead to the creation of new branches in the tableau, saturating rules only extend a branch \lstinline!b! with new formulae \lstinline[breaklines=true]!b' = [$\psi_1$,$\ldots$,$\psi_n$]!, which we denote by \lstinline!&\sexpands{b'}{b}&!.
Furthermore, saturating rules are restricted such that no new subterm may be created by their application.
For example, the rule
\begin{center}
\lstinline!(s $\inS$ t$_\text{1}$) $\in$ set b $\Longrightarrow$ &\sexpands{[s $\inS$ t$_\text{1}$ $\unionS$ t$_\text{2}$]}{b}&!
\end{center}
may only be used under the condition
\begin{center}
  \lstinline!t$_\text{1}$ $\unionS$ t$_\text{2}$ $\in$ subterms_fm (last b)!.
\end{center}
This ensures that repeated application of saturating rules eventually results in a \textit{linearly saturated} branch, i.e.\ a branch where no application of saturating rules would produce new formulae.
In Isabelle, we express this as follows.
\begin{lstlisting}
definition lin_sat b $\equiv$
  $\forall$b'. &\sexpands{b'}{b}& $\longrightarrow$ set b' $\subseteq$ set b
\end{lstlisting}
\todo[inline]{Reference figure and mention missing rule + example}

\subsection{Fulfilling Expansion Rules\label{sec:fulfilling}}
Since the number of branches doubles each time we apply a fulfilling rule, it is prudent to only apply them to open, linearly saturated branches. 
To further prevent unnecessary branching, each rule has a \textit{subsumption} condition. 

\begin{lstlisting}
definition sat b $\equiv$ lin_sat b $\land$ ($\nexists$bs'. &\fexpands{bs'}{b}&)
\end{lstlisting}

\section{Completeness of the Calculus}

\begin{lstlisting}
definition wf_branch b $\equiv$ $\exists$$\phi$. &\expandss{b}{[$\phi$]}&
\end{lstlisting}

\begin{lstlisting}
definition params :: 'a branch $\Rightarrow$ 'a set where
  params b $\equiv$ vars_branch b - vars_fm (last b)
\end{lstlisting}

\begin{lstlisting}
definition params' :: 'a branch $\Rightarrow$ 'a set where
  params' b $\equiv$
    {c $\in$ params b. $\forall$t $\in$ subterms_fm (last b).
      AT (Var c $\eqS$ t) $\notin$ set b $\land$
      AT (t $\eqS$ Var c) $\notin$ set b} 
\end{lstlisting}

\begin{lstlisting}
definition subterms_branch' ::
    'a branch $\Rightarrow$ 'a pset_term set where
  subterms_branch' b $\equiv$
    subterms_fm (last b) $\cup$ 
    Var ` (params b - params' b)
\end{lstlisting}

\begin{lstlisting}
definition bgraph $\equiv$ $\ldots$ 
\end{lstlisting}

\begin{lstlisting}
definition no_new_subterms b $\equiv$
  $\forall$t $\in$ subterms_branch b. t $\notin$ Var ` params b
    $\longrightarrow$ t $\in$ subterms_fm (last b))
\end{lstlisting}

\subsection{Building a Model: Realisation of a Branch}
Idea: keep this short. The formalisation matches the pen-and-paper proof quite closely.
Show the results in Realisation of an Open Branch.

\subsection{Formalising the Key Technical Lemma}
Only one quite trivial invariant needed 

\section{An Abstract Specification of the Decision Procedure}
Think about using the notion of coherent (or is this wfbranch?)
\begin{figure*}
  \centering
\begin{lstlisting}
function mlss_proc_branch :: 'a branch $\Rightarrow$ bool where
  $\neg$ lin_sat b $\Longrightarrow$
  mlss_proc_branch = mlss_proc_branch ((SOME b'. &\sexpands{b'}{b}& $\land$ set b $\subset$ set (b' @ b)) @ b)
|  $\llbracket$ $\neg$ sat b; bopen b; lin_sat b $\rrbracket$ $\Longrightarrow$
   mlss_proc_branch b = ($\forall$b' $\in$ (SOME bs. &\fexpands{bs}{b}&). mlss_proc_branch (b' @ b))
| $\llbracket$ lin_sat b; sat b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = bclosed b
| $\llbracket$ lin_sat b; bclosed b $\rrbracket$ $\Longrightarrow$ mlss_proc_branch b = True

definition mlss_proc :: 'a pset_fm $\Rightarrow$ bool where
  mlss_proc $\phi$ $\equiv$ mlss_proc_branch [$\phi$]
\end{lstlisting}
\caption{Definition of the function \lstinline|mlss_proc_branch| and \lstinline|mlss_proc|.}
\end{figure*}

\subsection{Termination}
Maybe interesting: technical lemma that allows to obtain the point at which a parameter was introduced.
\subsection{Soundness}
Interesting: The model changes because auf new parameters.
Maybe move this to the chapter on the calculus?
\subsection{Lifting the Completeness of the Calculus}
\todo[inline]{Do you even lift?}

\section{Future Work}
Challenges in obtaining an executable specification: membership cycle test unnecessary, fast branch membership test, proof reconstruction.
Additional constructs such as finiteness and pairs.
Optimisations for the algorithm.

\section{Conclusion}
\todo[inline]{Conclude}

\begin{acks}
  \todo[inline]{Acknowledge}
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sources}

\end{document}
